<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.1.2 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-structured-headers-00" category="info">

  <front>
    <title>Structured Headers for HTTP</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>
    <author initials="P-H." surname="Kamp" fullname="Poul-Henning Kamp">
      <organization>The Varnish Cache Project</organization>
      <address>
        <email>phk@varnish-cache.org</email>
      </address>
    </author>

    <date year="2017"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document describes Structured Headers, a way of simplifying HTTP header field definition and parsing. It is intended for use by new HTTP header fields.</t>



    </abstract>


    <note title="Note to Readers">


<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/structured-headers">https://github.com/mnot/I-D/labels/structured-headers</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/structured-headers/">https://mnot.github.io/I-D/structured-headers/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/structured-headers">https://github.com/mnot/I-D/commits/gh-pages/structured-headers</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Specifying the syntax of new HTTP header fields is an onerous task; even with the guidance in <xref target="RFC7231"/>, Section 8.3.1, there are many decisions – and pitfalls – for a prospective HTTP header field author.</t>

<t>Likewise, parsers often need to be written for specific HTTP headers, because each has slightly different handling of what looks like common syntax.</t>

<t>This document introduces structured HTTP header field values (hereafter, Structured Headers) to address these problems. Structured Headers define a generic, abstract model for data, along with a concrete serialisation for expressing that model in textual HTTP headers, as used by HTTP/1 <xref target="RFC7230"/> and HTTP/2 <xref target="RFC7540"/>.</t>

<t>In doing so, it allows new headers to be defined much more easily and reliably. Likewise, it offers a single parsing model for the headers that use the syntax.</t>

<t>Additionally, future versions of HTTP can define alternative serialisations of the abstract model, allowing headers that use it to be transmitted more efficiently without being redefined.</t>

<t>Note that it is not a goal of this document to redefine the syntax of existing HTTP headers; the mechanisms described herein are only intended to be used with headers that explicitly opt into them.</t>

<t>To specify a header field that uses Structured Headers, see <xref target="specify"/>.</t>

<t><xref target="types"/> defines a number of abstract data types that can be used in Structured Headers, of which only three are allowed at the “top” level: lists, dictionaries, or items.</t>

<t>Those abstract types can be serialised into textual headers – such as those used in HTTP/1 and HTTP/2 – using the algorithms described in <xref target="text"/>.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

<t>This document uses the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/>, including the DIGIT, ALPHA and DQUOTE rules from that document. It also includes the OWS rule from <xref target="RFC7230"/>.</t>

</section>
</section>
<section anchor="specify" title="Specifying Structured Headers">

<t>HTTP headers that use Structured Headers need to be defined to do so explicitly; recipients and generators need to know that the requirements of this document are in effect. The simplest way to do that is by referencing this document in its definition.</t>

<t>The field’s definition will also need to specify the field-value’s allowed syntax, in terms of the types described in <xref target="types"/>, along with their associated semantics.</t>

<t>Field definitions MUST NOT relax or otherwise modify the requirements of this specification; doing so would preclude handling by generic software.</t>

<t>However, field definitions are encouraged to clearly state additional constraints upon the syntax, as well as the consequences when those constraints are violated.</t>

<t>For example:</t>

<figure><artwork><![CDATA[
# FooExample Header

The FooExample HTTP header field conveys a list of numbers about how much Foo the
sender has.

FooExample is a Structured header [RFCxxxx]. Its value MUST be a dictionary ([RFCxxxx],
Section Y.Y). 

The dictionary MUST contain:

* A member whose key is "foo", and whose value is an integer ([RFCxxxx], Section Y.Y),
  indicating the number of foos in the message.
* A member whose key is "bar", and whose value is a string ([RFCxxxx], Section Y.Y),
  conveying the characteristic bar-ness of the message.

If the parsed header field does not contain both, it MUST be ignored.
]]></artwork></figure>

<t>Note that empty header field values are not allowed by the syntax, and therefore will be considered errors.</t>

</section>
<section anchor="text" title="Parsing Requirements for Textual Headers">

<t>When a receiving implementation parses textual HTTP header fields (e.g., in HTTP/1 or HTTP/2) that are known to be Structured Headers, it is important that care be taken, as there are a number of edge cases that can cause interoperability or even security problems. This section specifies the algorithm for doing so.</t>

<t>Given an ASCII string input_string that represents the chosen header’s field-value, return the parsed header value. Note that input_string may incorporate multiple header lines combined into one comma-separated field-value, as per <xref target="RFC7230"/>, Section 3.2.2.</t>

<t><list style="numbers">
  <t>Discard any OWS from the beginning of input_string.</t>
  <t>If the field-value is defined to be a dictionary, return the result of Parsing a Dictionary from Textual headers (<xref target="dictionary"/>).</t>
  <t>If the field-value is defined to be a list, return the result of Parsing a List from Textual Headers (<xref target="list"/>).</t>
  <t>Otherwise, return the result of Parsing an Item from Textual Headers (<xref target="item"/>).</t>
</list></t>

<t>Note that in the case of lists and dictionaries, this has the effect of combining multiple instances of the header field into one. However, for singular items, it has the effect of selecting the first value and ignoring any subsequent instances of the field, as well as extraneous text after the item.</t>

<t>Additionally, note that the effect of the parsing algorithms as specified is generally intolerant of syntax errors; if one is encountered, the typical response is to throw an error, thereby discarding the entire header field value.</t>

</section>
<section anchor="types" title="Structured Header Data Types">

<t>This section defines the abstract value types that can be composed into Structured Headers, along with the textual HTTP serialisations of them.</t>

<section anchor="number" title="Numbers">

<t>Abstractly, numbers are integers with an optional fractional part. They have a maximum of fifteen digits available to be used in one or both of the parts, as reflected in the ABNF below; this allows them to be stored as IEEE 754 double precision numbers (binary64) (<xref target="IEEE754"/>).</t>

<t>The textual HTTP serialisation of numbers allows a maximum of fifteen digits between the integer and fractional part, along with an optional “-“ indicating negative numbers.</t>

<figure><artwork type="abnf"><![CDATA[
number   = ["-"] ( "." 1*15DIGIT /
             DIGIT "." 1*14DIGIT /
            2DIGIT "." 1*13DIGIT /
            3DIGIT "." 1*12DIGIT /
            4DIGIT "." 1*11DIGIT /
            5DIGIT "." 1*10DIGIT /
            6DIGIT "." 1*9DIGIT /
            7DIGIT "." 1*8DIGIT /
            8DIGIT "." 1*7DIGIT /
            9DIGIT "." 1*6DIGIT /
           10DIGIT "." 1*5DIGIT /
           11DIGIT "." 1*4DIGIT /
           12DIGIT "." 1*3DIGIT /
           13DIGIT "." 1*2DIGIT /
           14DIGIT "." 1DIGIT /
           15DIGIT )

integer  = ["-"] 1*15DIGIT
unsigned = 1*15DIGIT
]]></artwork></figure>

<t>integer and unsigned are defined as conveniences to specification authors; if their use is specified and their ABNF is not matched, a parser MUST consider it to be invalid.</t>

<t>For example, a header whose value is defined as a number could look like:</t>

<figure><artwork><![CDATA[
ExampleNumberHeader: 4.5
]]></artwork></figure>

<section anchor="parsing-numbers-from-textual-headers" title="Parsing Numbers from Textual Headers">

<t>TBD</t>

</section>
</section>
<section anchor="string" title="Strings">

<t>Abstractly, strings are ASCII strings <xref target="RFC0020"/>, excluding control characters (i.e., the range 0x20 to 0x7E). Note that this excludes tabs, newlines and carriage returns. They may be at most 1024 characters long.</t>

<t>The textual HTTP serialisation of strings uses a backslash (“") to escape double quotes and backslashes in strings.</t>

<figure><artwork type="abnf"><![CDATA[
string    = DQUOTE 1*1024(char) DQUOTE
char      = unescaped / escape ( DQUOTE / "\" )
unescaped = %x20-21 / %x23-5B / %x5D-7E
escape    = "\"
]]></artwork></figure>

<t>For example, a header whose value is defined as a string could look like:</t>

<figure><artwork><![CDATA[
ExampleStringHeader: "hello world"
]]></artwork></figure>

<t>Note that strings only use DQUOTE as a delimiter; single quotes do not delimit strings.</t>

<t>Unicode is not directly supported in Structured Headers, because it causes a number of interoperability issues, and – with few exceptions – header values do not require it.</t>

<t>When it is necessary for a field value to convey non-ASCII string content, binary content (<xref target="binary"/>) SHOULD be specified, along with a character encoding (most likely, UTF-8).</t>

<section anchor="parsing-a-string-from-textual-headers" title="Parsing a String from Textual Headers">

<t>Given an ASCII string input_string, return an unquoted string. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>Let output_string be an empty string.</t>
  <t>If the first character of input_string is not DQUOTE, throw an error.</t>
  <t>Discard the first character of input_string.</t>
  <t>If input_string contains more than 1025 characters, throw an error.</t>
  <t>While input_string is not empty:
  <list style="numbers">
      <t>Let char be the result of removing the first character of input_string.</t>
      <t>If char is a backslash (“\”):
      <list style="numbers">
          <t>If input_string is now empty, throw an error.</t>
          <t>Else:
          <list style="numbers">
              <t>Let next_char be the result of removing the first character of input_string.</t>
              <t>If next_char is not DQUOTE or “\”, throw an error.</t>
              <t>Append next_char to output_string.</t>
            </list></t>
        </list></t>
      <t>Else, if char is DQUOTE, remove the first character of input_string and return output_string.</t>
      <t>Else, append char to output_string.</t>
    </list></t>
  <t>Otherwise, throw an error.</t>
</list></t>

</section>
</section>
<section anchor="label" title="Labels">

<t>Labels are short (up to 256 characters) textual identifiers; their abstract model is identical to their expression in the textual HTTP serialisation.</t>

<figure><artwork type="abnf"><![CDATA[
label = lcalpha *255( lcalpha / DIGIT / "_" / "-"/ "*" / "/" )
lcalpha = %x61-7A ; a-z
]]></artwork></figure>

<t>Note that labels can only contain lowercase letters.</t>

<t>For example, a header whose value is defined as a label could look like:</t>

<figure><artwork><![CDATA[
ExampleLabelHeader: foo/bar
]]></artwork></figure>

<section anchor="parsing-a-label-from-textual-headers" title="Parsing a Label from Textual Headers">

<t>Given an ASCII string input_string, return a label. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>If input_string contains more than 256 characters, throw an error.</t>
  <t>If the first character of input_string is not ALPHA, throw an error.</t>
  <t>Let output_string be an empty string.</t>
  <t>While input_string is not empty:
  <list style="numbers">
      <t>Let char be the result of removing the first character of input_string.</t>
      <t>If char is not one of ALPHA, DIGIT, “_”, “-“, “*” or “/”:
      <list style="numbers">
          <t>Prepend char to input_string.</t>
          <t>Return output_string.</t>
        </list></t>
      <t>Append char to output_string.</t>
    </list></t>
  <t>Return output_string.</t>
</list></t>

</section>
</section>
<section anchor="binary" title="Binary Content">

<t>Arbitrary binary content up to 16K in size can be conveyed in Structured Headers.</t>

<t>The textual HTTP serialisation indicates their presence by a leading “*”, with the data encoded using Base 64 Encoding <xref target="RFC4648"/>, without padding (as “=” might be confused with the use of dictionaries).</t>

<figure><artwork type="abnf"><![CDATA[
binary = '*' 1*21846(base64)
base64 = ALPHA / DIGIT / "+" / "/"
]]></artwork></figure>

<t>For example, a header whose value is defined as binary content could look like:</t>

<figure><artwork><![CDATA[
ExampleBinaryHeader: *cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg
]]></artwork></figure>

<section anchor="parsing-binary-content-from-textual-headers" title="Parsing Binary Content from Textual Headers">

<t>Given an ASCII string input_string, return binary content. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>If the first character of input_string is not “*”, throw an error.</t>
  <t>Discard the first character of input_string.</t>
  <t>Let b64_content be the result of removing content of input_string up to but not including the first character that is not in ALPHA, DIGIT, “+” or “/”.</t>
  <t>Let binary_content be the result of Base 64 Decoding <xref target="RFC4648"/> b64_content, synthesising padding if necessary. If an error is encountered, throw it.</t>
  <t>Return binary_content.</t>
</list></t>

</section>
</section>
<section anchor="item" title="Items">

<t>An item is can be a number (<xref target="number"/>), string (<xref target="string"/>), label (<xref target="label"/>) or binary content (<xref target="binary"/>).</t>

<figure><artwork type="abnf"><![CDATA[
item = number / string / label / binary
]]></artwork></figure>

<section anchor="parsing-an-item-from-textual-headers" title="Parsing an Item from Textual Headers">

<t>Given an ASCII string input_string, return an item. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>Discard any OWS from the beginning of input_string.</t>
  <t>If the first character of input_string is a “-“ or a DIGIT, process input_string as a number (<xref target="number"/>) and return the result, throwing any errors encountered.</t>
  <t>If the first character of input_string is a DQUOTE, process input_string as a string (<xref target="string"/>) and return the result, throwing any errors encountered.</t>
  <t>If the first character of input_string is “*”, process input_string as binary content (<xref target="binary"/>) and return the result, throwing any errors encountered.</t>
  <t>If the first character of input_string is an ALPHA, process input_string as a label (<xref target="label"/>) and return the result, throwing any errors encountered.</t>
  <t>Otherwise, throw an error.</t>
</list></t>

</section>
</section>
<section anchor="dictionary" title="Dictionaries">

<t>Dictionaries are unordered maps of key-value pairs, where the keys are labels (<xref target="label"/>) and the values are items (<xref target="item"/>). There can be between 1 and 1024 members, and keys are required to be unique.</t>

<t>In the textual HTTP serialisation, keys and values are separated by “=” (without whitespace), and key/value pairs are separated by a comma with optional whitespace.</t>

<figure><artwork type="abnf"><![CDATA[
dictionary = label "=" item *1023( OWS "," OWS label "=" item )
]]></artwork></figure>

<t>For example, a header field whose value is defined as a dictionary could look like:</t>

<figure><artwork><![CDATA[
ExampleDictHeader: foo=1.23, da="Applepie", en=*w4ZibGV0w6ZydGUK
]]></artwork></figure>

<t>Typically, a header field specification will define the semantics of individual keys, as well as whether their presence is required or optional. Recipients MUST ignore keys that are undefined or unknown, unless the header field’s specification specifically disallows them.</t>

<section anchor="parsing-a-dictionary-from-textual-headers" title="Parsing a Dictionary from Textual Headers">

<t>Given an ASCII string input_string, return a mapping of (label, item). input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>Let dictionary be an empty mapping.</t>
  <t>While input_string is not empty:
  <list style="numbers">
      <t>Let this_key be the result of running Parse Label from Textual Headers (<xref target="label"/>) with input_string. If an error is encountered, throw it.</t>
      <t>If dictionary already contains this_key, raise an error.</t>
      <t>Consume a “=” from input_string; if none is present, raise an error.</t>
      <t>Let this_value be the result of running Parse Item from Textual Headers (<xref target="item"/>) with input_string. If an error is encountered, throw it.</t>
      <t>Add key this_key with value this_value to dictionary.</t>
      <t>Discard any leading OWS from input_string.</t>
      <t>If input_string is empty, return dictionary.</t>
      <t>Consume a COMMA from input_string; if no comma is present, raise an error.</t>
      <t>Discard any leading OWS from input_string.</t>
    </list></t>
  <t>Return dictionary.</t>
</list></t>

</section>
</section>
<section anchor="list" title="Lists">

<t>Lists are arrays of items (<xref target="item"/>), with one to 1024 members.</t>

<t>In the textual HTTP serialisation, each item is separated by a comma and optional whitespace.</t>

<figure><artwork type="abnf"><![CDATA[
list = item 1*1024( OWS "," OWS item )
]]></artwork></figure>

<t>For example, a header field whose value is defined as a list of labels could look like:</t>

<figure><artwork><![CDATA[
ExampleListHeader: foo, bar, baz_45
]]></artwork></figure>

<section anchor="parsing-a-list-from-textual-headers" title="Parsing a List from Textual Headers">

<t>Given an ASCII string input_string, return a list of items. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>Let items be an empty array.</t>
  <t>While input_string is not empty:
  <list style="numbers">
      <t>Let item be the result of running Parse Item from Textual Headers (<xref target="item"/>) with input_string. If an error is encountered, throw it.</t>
      <t>Append item to items.</t>
      <t>Discard any leading OWS from input_string.</t>
      <t>If input_string is empty, return items.</t>
      <t>Consume a COMMA from input_string; if no comma is present, raise an error.</t>
      <t>Discard any leading OWS from input_string.</t>
    </list></t>
  <t>Return items.</t>
</list></t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This draft has no actions for IANA.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>TBD</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC0020" target='https://www.rfc-editor.org/info/rfc20'>
<front>
<title>ASCII format for network interchange</title>
<author initials='V.G.' surname='Cerf' fullname='V.G. Cerf'><organization /></author>
<date year='1969' month='October' />
</front>
<seriesInfo name='STD' value='80'/>
<seriesInfo name='RFC' value='20'/>
<seriesInfo name='DOI' value='10.17487/RFC0020'/>
</reference>



<reference  anchor="RFC4648" target='https://www.rfc-editor.org/info/rfc4648'>
<front>
<title>The Base16, Base32, and Base64 Data Encodings</title>
<author initials='S.' surname='Josefsson' fullname='S. Josefsson'><organization /></author>
<date year='2006' month='October' />
<abstract><t>This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4648'/>
<seriesInfo name='DOI' value='10.17487/RFC4648'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="IEEE754" target="http://grouper.ieee.org/groups/754/">
  <front>
    <title>IEEE Standard for Floating-Point Arithmetic</title>
    <author >
      <organization>IEEE</organization>
    </author>
    <date year="2008"/>
  </front>
</reference>




<reference  anchor="RFC7231" target='https://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference  anchor="RFC7540" target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>




    </references>



  </back>

<!-- ##markdown-source:
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
AX93iwdOwb8ANoJv62VAAAA=

-->

</rfc>

