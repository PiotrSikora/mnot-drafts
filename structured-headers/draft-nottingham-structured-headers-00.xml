<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.1.2 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-structured-headers-00" category="info">

  <front>
    <title>Structured Headers for HTTP</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization></organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date year="2017"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document describes Structured Headers, a convention for the syntax of HTTP header fields that simplifies header field definition and parsing.</t>



    </abstract>


    <note title="Note to Readers">


<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/structured-headers">https://github.com/mnot/I-D/labels/structured-headers</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/structured-headers/">https://mnot.github.io/I-D/structured-headers/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/structured-headers">https://github.com/mnot/I-D/commits/gh-pages/structured-headers</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Specifying the syntax of new HTTP header fields is an onerous task; even with the guidance in <xref target="RFC7231"/>, Section 8.3.1, there are many decisions – and pitfalls – for a prospective HTTP header field author.</t>

<t>Likewise, parsers often need to be written for specific HTTP headers, because each has slightly different handling of what looks like common syntax.</t>

<t>This document introduces structured HTTP header field values (hereafter, Structured Headers) to address these problems. Structured Headers define a generic, abstract model for data, along with a concrete serialisation for expressing that model in textual HTTP headers, as used by HTTP/1 <xref target="RFC7230"/> and HTTP/2 <xref target="RFC7540"/>.</t>

<t>In doing so, it allows new headers to be defined much more easily and reliably. Likewise, it offers a single parsing model for the headers that use the syntax.</t>

<t>Additionally, future versions of HTTP can define alternative serialisations of the abstract model, allowing headers that use it to be transmitted more efficiently without being redefined.</t>

<t>Note that it is not a goal of this document to redefine the syntax of existing HTTP headers; the mechanisms described herein are only intended to be used with headers that explicitly opt into them.</t>

<t>To specify a header field that uses Structured Headers, see <xref target="specify"/>.</t>

<t><xref target="types"/> defines a number of abstract data types that can be used in Structured Headers, of which only three are allowed at the “top” level: lists, dictionaries, or items.</t>

<t>Those abstract types can be serialised into textual headers – such as those used in HTTP/1 and HTTP/2 – using the algorithms described in <xref target="text"/>.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

<t>This document uses the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/>, including the DIGIT, ALPHA and DQUOTE rules from that document.</t>

</section>
</section>
<section anchor="specify" title="Specifying Structured Headers">

<t>HTTP headers that use Structured Headers need to be defined to do so explicitly; recipients and generators need to know that the requirements of this document are in effect. The simplest way to do that is by referencing this document in its definition.</t>

<t>The field’s definition will also need to specify the field-value’s allowed syntax, in terms of the types described in <xref target="types"/>, along with their associated semantics.</t>

<t>Field definitions MUST NOT relax or otherwise modify the requirements of this specification; doing so would preclude handling by generic software.</t>

<t>However, field definitions are encouraged to clearly state additional constraints upon the syntax, as well as the consequences when those constraints are violated.</t>

<t>For example:</t>

<figure><artwork><![CDATA[
# FooExample Header

The FooExample HTTP header field conveys a list of numbers about how much Foo the
sender has.

FooExample is a Structured header [RFCxxxx]. Its value MUST be a list ([RFCxxxx],
{{list}}) of numbers ([RFCxxxx], {{numbers}}). These numbers MUST be positive
integers. Values that violate these requirements MUST be ignored.
]]></artwork></figure>

<t>Note that empty header field values are not allowed by the syntax, and therefore will be considered errors.</t>

</section>
<section anchor="text" title="Parsing Requirements for Textual Headers">

<t>When a receiving implementation parses textual HTTP header fields (e.g., in HTTP/1 or HTTP/2) that are known to be Structured Headers, it is important that care be taken, as there are a number of edge cases that can cause interoperability or even security problems. This section specifies the algorithm for doing so.</t>

<t>Given an ASCII string input_string that represents the chosen header’s field-value, return the parsed header value. Note that input_string may incorporate multiple header lines combined into one comma-separated field-value, as per <xref target="RFC7230"/>, Section 3.2.2.</t>

<t><list style="numbers">
  <t>Discard any OWS from the beginning of input_string.</t>
  <t>If the field-value is defined to be a dictionary, return the result of Parsing a Dictionary from Textual heaers (<xref target="dictionary"/>).</t>
  <t>If the field-value is defined to be a list, return the result of Parsing a List from Textual Headers (<xref target="list"/>).</t>
  <t>Otherwise, return the result of Parsing an Item from Textual Headers (<xref target="item"/>).</t>
</list></t>

<t>Note that in the case of lists and dictionaries, this has the effect of combining multiple instances of the header field into one. However, for singular items, it has the effect of selecting the first value and ignoring any subsequent instances of the field, as well as extraneous text after the item.</t>

<t>Additionally, note that the effect of the parsing algorithms as specified is generally intolerant of syntax errors; if one is encountered, the typical response is to throw an error, thereby discarding the entire header field value.</t>

</section>
<section anchor="types" title="Structured Header Data Types">

<t>This section defines the abstract value types that can be composed into Structured Headers, along with the textual HTTP serialisations of them.</t>

<section anchor="number" title="Numbers">

<t>Abstractly, numbers are integers within the range -(2**53)+1 to (2**53)-1, with an optional fractional part. They MUST NOT express greater magnitude or precision than an IEEE 754 double precision number (<xref target="IEEE754"/>) provides.</t>

<t>The textual HTTP serialisation of numbers allows a maximum of fifteen digits between the integer and fractional part, along with an optional “-“ indicating negative numbers.</t>

<figure><artwork type="abnf"><![CDATA[
number = ["-"] ( "." 1*15DIGIT /
           DIGIT "." 1*14DIGIT /
          2DIGIT "." 1*13DIGIT /
          3DIGIT "." 1*12DIGIT /
          4DIGIT "." 1*11DIGIT /
          5DIGIT "." 1*10DIGIT /
          6DIGIT "." 1*9DIGIT /
          7DIGIT "." 1*8DIGIT /
          8DIGIT "." 1*7DIGIT /
          9DIGIT "." 1*6DIGIT /
         10DIGIT "." 1*5DIGIT /
         11DIGIT "." 1*4DIGIT /
         12DIGIT "." 1*3DIGIT /
         13DIGIT "." 1*2DIGIT /
         14DIGIT "." 1DIGIT /
         15DIGIT )
]]></artwork></figure>

<t>For example, a header whose value is defined as a number could look like:</t>

<figure><artwork><![CDATA[
ExampleNumberHeader: 4.5
]]></artwork></figure>

<section anchor="parsing-numbers-from-textual-headers" title="Parsing Numbers from Textual Headers">

<t>TBD</t>

</section>
</section>
<section anchor="string" title="Strings">

<t>Abstractly, strings are ASCII strings <xref target="RFC0020"/>, excluding control characters (i.e., the range 0x20 to 0x7E). Note that this excludes tabs, newlines and carriage returns. They may be at most 1024 characters long.</t>

<t>The textual HTTP serialisation of strings uses a backslash (“") to escape double quotes and backslashes in strings.</t>

<figure><artwork type="abnf"><![CDATA[
string    = DQUOTE 1*1024(char) DQUOTE
char      = unescaped / escape ( DQUOTE / "\" )
unescaped = %x20-21 / %x23-5B / %x5D-7E
escape    = "\"
]]></artwork></figure>

<t>For example, a header whose value is defined as a string could look like:</t>

<figure><artwork><![CDATA[
ExampleStringHeader: "hello world"
]]></artwork></figure>

<t>Unicode is not directly supported in Structured Headers, because it causes a number of interoperability issues, and – with few exceptions – header values do not require it.</t>

<t>When it is necessary for a field value to convey non-ASCII string content, binary content (<xref target="binary"/>) SHOULD be specified, along with a character encoding (most likely, UTF-8).</t>

<section anchor="parsing-a-string-from-textual-headers" title="Parsing a String from Textual Headers">

<t>Given an ASCII string input_string, return an unquoted string. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>Let output_string be an empty string.</t>
  <t>If the first character of input_string is not DQUOTE, throw an error.</t>
  <t>Discard the first character of input_string.</t>
  <t>If input_string contains more than 1025 characters, throw an error.</t>
  <t>While input_string is not empty:
  <list style="numbers">
      <t>Let char be the result of removing the first character of input_string.</t>
      <t>If char is a backslash (“\”):
      <list style="numbers">
          <t>If input_string is now empty, throw an error.</t>
          <t>Else:
          <list style="numbers">
              <t>Let next_char be the result of removing the first character of input_string.</t>
              <t>If next_char is not DQUOTE or “\”, throw an error.</t>
              <t>Append next_char to output_string.</t>
            </list></t>
        </list></t>
      <t>Else, if char is DQUOTE, remove the first character of input_string and return output_string.</t>
      <t>Else, append char to output_string.</t>
    </list></t>
  <t>Otherwise, throw an error.</t>
</list></t>

</section>
</section>
<section anchor="label" title="Labels">

<t>Labels are short (up to 256 characters) textual identifiers; their abstract model is identical to their expression in the textual HTTP serialisation.</t>

<figure><artwork type="abnf"><![CDATA[
label = ALPHA *255( ALPHA / DIGIT / "_" / "-" )
]]></artwork></figure>

<t>For example, a header whose value is defined as a label could look like:</t>

<figure><artwork><![CDATA[
ExampleLabelHeader: foo
]]></artwork></figure>

<section anchor="parsing-a-label-from-textual-headers" title="Parsing a Label from Textual Headers">

<t>Given an ASCII string input_string, return a label. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>If input_string contains more than 256 characters, throw an error.</t>
  <t>If the first character of input_string is not ALPHA, throw an error.</t>
  <t>Let output_string be an empty string.</t>
  <t>While input_string is not empty:
  <list style="numbers">
      <t>Let char be the result of removing the first character of input_string.</t>
      <t>If char is not one of ALPHA, DIGIT, “_”, or “-“:
      <list style="numbers">
          <t>Prepend char to input_string.</t>
          <t>Return output_string.</t>
        </list></t>
      <t>Append char to output_string.</t>
    </list></t>
  <t>Return output_string.</t>
</list></t>

</section>
</section>
<section anchor="binary" title="Binary Content">

<t>Arbitrary binary content up to 16K in size can be conveyed in Structured Headers.</t>

<t>The textual HTTP serialisation indicates their presence by a leading “*”, with the data encoded using Base 64 Encoding <xref target="RFC4648"/>, without padding (as “=” might be confused with the use of dictionaries).</t>

<figure><artwork type="abnf"><![CDATA[
binary = '*' 1*21846(base64)
base64 = ALPHA / DIGIT / "+" / "/"
]]></artwork></figure>

<t>For example, a header whose value is defined as binary content could look like:</t>

<figure><artwork><![CDATA[
ExampleBinaryHeader: *cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg
]]></artwork></figure>

<section anchor="parsing-binary-content-from-textual-headers" title="Parsing Binary Content from Textual Headers">

<t>Given an ASCII string input_string, return binary content. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>If the first character of input_string is not “*”, throw an error.</t>
  <t>Discard the first character of input_string.</t>
  <t>Let b64_content be the result of removing content of input_string up to but not including the first character that is not in ALPHA, DIGIT, “+” or “/”.</t>
  <t>Let binary_content be the result of Base 64 Decoding <xref target="RFC4648"/> b64_content, synthesising padding if necessary. If an error is encountered, throw it.</t>
  <t>Return binary_content.</t>
</list></t>

</section>
</section>
<section anchor="item" title="Items">

<t>An item is can be a number (<xref target="number"/>), string (<xref target="string"/>), label (<xref target="label"/>) or binary content (<xref target="binary"/>).</t>

<figure><artwork type="abnf"><![CDATA[
item = number / string / label / binary
]]></artwork></figure>

<section anchor="parsing-an-item-from-textual-headers" title="Parsing an Item from Textual Headers">

<t>Given an ASCII string input_string, return an item. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>Discard any OWS from the beginning of input_string.</t>
  <t>If the first character of input_string is a “-“ or a DIGIT, process input_string as a number (<xref target="number"/>) and return the result, throwing any errors encountered.</t>
  <t>If the first character of input_string is a DQUOTE, process input_string as a string (<xref target="string"/>) and return the result, throwing any errors encountered.</t>
  <t>If the first character of input_string is “*”, process input_string as binary content (<xref target="binary"/>) and return the result, throwing any errors encountered.</t>
  <t>If the first character of input_string is an ALPHA, process input_string as a label (<xref target="label"/>) and return the result, throwing any errors encountered.</t>
  <t>Otherwise, throw an error.</t>
</list></t>

</section>
</section>
<section anchor="dictionary" title="Dictionaries">

<t>Dictionaries are unordered maps of key-value pairs, where the keys are labels (<xref target="label"/>) and the values are items (<xref target="item"/>). There can be between 1 and 1024 members, and keys are required to be unique.</t>

<t>In the textual HTTP serialisation, keys and values are separated by “=” (without whitespace), and key/value pairs are separated by a comma with optional whitespace.</t>

<figure><artwork type="abnf"><![CDATA[
dictionary = label "=" item *1023( OWS "," OWS label "=" item )
]]></artwork></figure>

<t>For example, a header field whose value is defined as a dictionary could look like:</t>

<figure><artwork><![CDATA[
ExampleDictHeader: foo=1.232, bar="We hold these truths...", baz=testing1
    *baz=cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg
]]></artwork></figure>

<section anchor="parsing-a-dictionary-from-textual-headers" title="Parsing a Dictionary from Textual Headers">

<t>Given an ASCII string input_string, return a mapping of (label, item). input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>Let dictionary be an empty mapping.</t>
  <t>While input_string is not empty:</t>
  <t>Let this_key be the result of running Parse Label from Textual Headers (<xref target="label"/>) with input_string. If an error is encountered, throw it.</t>
  <t>If dictionary already contains this_key, raise an error.</t>
  <t>Consume a “=” from input_string; if none is present, raise an error.</t>
  <t>Let this_value be the result of running Parse Item from Textual Headers (<xref target="item"/>) with input_string. If an error is encountered, throw it.</t>
  <t>Add key this_key with value this_value to dictionary.</t>
  <t>Discard any leading OWS from input_string.</t>
  <t>If input_string is empty, return dictionary.</t>
  <t>Consume a COMMA from input_string; if no comma is present, raise an error.</t>
  <t>Discard any leading OWS from input_string.</t>
  <t>Return dictionary.</t>
</list></t>

</section>
</section>
<section anchor="list" title="Lists">

<t>Lists are arrays of items (<xref target="item"/>), with one to 1024 members.</t>

<t>In the textual HTTP serialisation, each item is separated by a comma and optional whitespace.</t>

<figure><artwork type="abnf"><![CDATA[
list = item 1*1024( OWS "," OWS item )
]]></artwork></figure>

<t>For example, a header field whose value is defined as a list of labels could look like:</t>

<figure><artwork><![CDATA[
ExampleListHeader: foo, bar, baz_45
]]></artwork></figure>

<section anchor="parsing-a-list-from-textual-headers" title="Parsing a List from Textual Headers">

<t>Given an ASCII string input_string, return a list of items. input_string is modified to remove the parsed value.</t>

<t><list style="numbers">
  <t>Let items be an empty array.</t>
  <t>While input_string is not empty:</t>
  <t>Let item be the result of running Parse Item from Textual Headers (<xref target="item"/>) with input_string. If an error is encountered, throw it.</t>
  <t>Append item to items.</t>
  <t>Discard any leading OWS from input_string.</t>
  <t>If input_string is empty, return items.</t>
  <t>Consume a COMMA from input_string; if no comma is present, raise an error.</t>
  <t>Discard any leading OWS from input_string.</t>
  <t>Return items.</t>
</list></t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This draft has no actions for IANA.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>TBD</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

<reference anchor="IEEE754" target="http://grouper.ieee.org/groups/754/">
  <front>
    <title>IEEE Standard for Floating-Point Arithmetic</title>
    <author >
      <organization>IEEE</organization>
    </author>
    <date year="2008"/>
  </front>
</reference>




<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC0020" target='https://www.rfc-editor.org/info/rfc20'>
<front>
<title>ASCII format for network interchange</title>
<author initials='V.G.' surname='Cerf' fullname='V.G. Cerf'><organization /></author>
<date year='1969' month='October' />
</front>
<seriesInfo name='STD' value='80'/>
<seriesInfo name='RFC' value='20'/>
<seriesInfo name='DOI' value='10.17487/RFC0020'/>
</reference>



<reference  anchor="RFC4648" target='https://www.rfc-editor.org/info/rfc4648'>
<front>
<title>The Base16, Base32, and Base64 Data Encodings</title>
<author initials='S.' surname='Josefsson' fullname='S. Josefsson'><organization /></author>
<date year='2006' month='October' />
<abstract><t>This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4648'/>
<seriesInfo name='DOI' value='10.17487/RFC4648'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor="RFC7231" target='https://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC7540" target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>




    </references>



  </back>

<!-- ##markdown-source:
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
GQKYaT2CVmcQpVbj/g4DUKPZ4H/XRtxZdNk+112lV7D4nTSIHCQov4667d5+
rymGMj9q/KTENOOXPul9ErDXYmra7XaDbv9+hB3TaUuXCfljuvI9HOr2w/Fv
q/Tg3XOH5Tus2Sardfc7O2SBWsNay63GmeIBxZabjBrsn+jlzU2GVNpMRNpR
d5S/tYhkn6wlrgfSD1+uBZuTSY4VlqsC18sKFUt6ZS1s7uBpcF9TzoiJkAOz
qKEkfLqcuuNl967Jtpn2A8VYv75HNQ95/eB7FIO8dRwzLqysxdO5HvNKUHq1
sdKf20vINXytVnGO9ap2S4eTJLOdP+fX9RUGod7ptdzjWzXvYOtu7R98lcT7
FWkNpbL9MH6p4+YRv1NCf09i3It+Ms/lkrPOeq5w9Su5CFXSQXJ4GPDzX5l4
WrwVsvm94bsRm9/aO7LTuNOgGkT/GcDsX0d0KfXu5hjGBuDMsMzg+6k/2Aah
t77g87VtMiejfS/++xDTGjoES3aCr4RK1vw/GQt6VVuJpaHGlP27gf+bWK8m
//8S5v6vJPiP4I7fHrNU9JanrP4WofoTQnqZCuLY1zfsO570SJtf+PEvN248
z+fg9Nd2dEIS/S+5RxTDyzsAAA==

-->

</rfc>

