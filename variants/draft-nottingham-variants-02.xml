<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.1.2 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-variants-02" category="std" updates="7234">

  <front>
    <title>HTTP Representation Variants</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date year="2018"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification introduces an alternative way to communicate a secondary cache key for a HTTP resource, using the HTTP “Variants” and “Variant-Key” response header fields. Its aim is to make HTTP proactive content negotiation more cache-friendly.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/variants">https://github.com/mnot/I-D/labels/variants</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/variants/">https://mnot.github.io/I-D/variants/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/variants">https://github.com/mnot/I-D/commits/gh-pages/variants</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-variants/">https://datatracker.ietf.org/doc/draft-nottingham-variants/</eref>.</t>

<t>There is a prototype implementation of the algorithms herein at <eref target="https://github.com/mnot/variants-toy">https://github.com/mnot/variants-toy</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP proactive content negotiation (<xref target="RFC7231"/>, Section 3.4.1) is seeing renewed interest in negotiation for language and other, newer attributes (for example, see <xref target="I-D.ietf-httpbis-client-hints"/>).</t>

<t>Successfully reusing negotiated responses that have been stored in a HTTP cache requires establishment of a secondary cache key (<xref target="RFC7234"/>, Section 4.1). Currently, the Vary header (<xref target="RFC7231"/>, Section 7.1.4) does this by nominating a set of request headers.</t>

<t>HTTP’s caching model allows a certain amount of latitude in normalising request header field values, so as to increase the chances of a cache hit while still respecting the semantics of that header. However, this is often inadequate; even when the headers’ semantics are understood, a cache does not know enough about the possible alternative representations available on the origin server to make an appropriate decision.</t>

<t>For example, if a cache has stored the following request/response pair:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: text/html
Content-Language: fr
Vary: Accept-Language
Transfer-Encoding: chunked

[French content]
]]></artwork></figure>

<t>Provided that the cache has full knowledge of the semantics of Accept-Language and Content-Language, it will know that a French representation is available and might be able to infer that an English representation is not available. But, it does not know (for example) whether a Japanese representation is available without making another request, incurring possibly unnecessary latency.</t>

<t>This specification introduces the HTTP Variants response header field (<xref target="variants"/>) to enumerate the available variant representations on the origin server, to provide clients and caches with enough information to properly satisfy requests – either by selecting a response from cache or by forwarding the request towards the origin – by following an algorithm defined in <xref target="cache"/>.</t>

<t>Its companion the Variant-Key response header field (<xref target="variant-key"/>) indicates which representation was selected, so that it can be reliably reused in the future. When this specification is in use, the example above might become:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: text/html
Content-Language: fr
Vary: Accept-Language
Variants: Accept-Language;fr;de;en;jp
Variant-Key: fr
Transfer-Encoding: chunked

[French content]
]]></artwork></figure>

<t>Proactive content negotiation mechanisms that wish to be used with Variants need to define how to do so explicitly; see <xref target="define"/>. It is best suited for negotiation over request headers that are well-understood. Variants also works best when content negotiation takes place over a constrained set of representations; since each variant needs to be listed in the header field, it is ill-suited for open-ended sets of representations.</t>

<t>Variants can be seen as a simpler version of the Alternates header field introduced by <xref target="RFC2295"/>; unlike that mechanism, Variants does not require specification of each combination of attributes, and does not assume that each combination has a unique URL.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

<t>This specification uses the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/> with a list extension, defined in Section 7 of <xref target="RFC7230"/>, that allows for compact definition of comma-separated lists using a ‘#’ operator (similar to how the ‘*’ operator indicates repetition).</t>

<t>Additionally, it uses the “field-name”, “OWS” and “token” rules from <xref target="RFC7230"/>.</t>

</section>
</section>
<section anchor="variants" title="The “Variants” HTTP Header Field">

<t>The Variants HTTP response header field indicates what representations are available for a given resource at the time that the response is produced, by enumerating the request header fields that it varies on, along with the values that are available for each.</t>

<figure><artwork><![CDATA[
Variants        = 1#variant-item
variant-item    = field-name *( OWS ";" OWS available-value )
available-value = token
]]></artwork></figure>

<t>Each “variant-item” indicates a request header field that carries a value that clients might proactively negotiate for; each parameter on it indicates a value for which there is an available representation on the origin server.</t>

<t>So, given this example header field:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip
]]></artwork></figure>

<t>a recipient can infer that the only content-coding available for that resource is “gzip” (along with the “identity” non-encoding; see <xref target="content-encoding"/>).</t>

<t>Given:</t>

<figure><artwork><![CDATA[
Variants: accept-encoding
]]></artwork></figure>

<t>a recipient can infer that no content-codings (beyond identity) are supported. Note that as always, field-name is case-insensitive.</t>

<t>A more complex example:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip;br, Accept-Language;en ;fr
]]></artwork></figure>

<t>Here, recipients can infer that two content-codings in addition to “identity” are available, as well as two content languages. Note that, as with all HTTP header fields that use the “#” list rule (see <xref target="RFC7230"/>, Section 7), they might occur in the same header field or separately, like this:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip;brotli
Variants: Accept-Language;en ;fr
]]></artwork></figure>

<t>The ordering of available-values after the field-name is significant, as it might be used by the header’s algorithm for selecting a response (see <xref target="content-encoding"/> for an example of this).</t>

<t>The ordering of the request header fields themselves indicates descending application of preferences; for example, in the headers above, a cache will serve gzip’d content regardless of language if it is available.</t>

<t>Origin servers SHOULD consistently send Variant header fields on all cacheable (as per <xref target="RFC7234"/>, Section 3) responses for a resource, since its absence will trigger caches to fall back to Vary processing.</t>

<t>Likewise, servers MUST send the Variant-Key response header field when sending Variants.</t>

<section anchor="vary" title="Relationship to Vary">

<t>Caches that fully implement this specification SHOULD ignore request header fields in the <spanx style="verb">Vary</spanx> header for the purposes of secondary cache key calculation (<xref target="RFC7234"/>, Section 4.1) when their semantics are implemented as per this specification and their corresponding response header field is listed in <spanx style="verb">Variants</spanx>.</t>

<t>If any member of the Vary header does not have a corresponding variant that is understood by the implementation, it is still subject to the requirements there.</t>

</section>
</section>
<section anchor="variant-key" title="The “Variant-Key” HTTP Header Field">

<t>The Variant-Key HTTP response header field is used to indicate the value(s) from the Variants header field that identify the representation it occurs within.</t>

<figure><artwork><![CDATA[
Variant-Key     = 1#available-value
]]></artwork></figure>

<t>Each value indicates the selected available-value, in the same order as the variants listed in the Variants header field.</t>

<t>Therefore, Variant-Key MUST be the same length (in comma-separated members) as Variants, and each member MUST correspond in position to its companion in Variants.</t>

<t>For example:</t>

<figure><artwork><![CDATA[
Variants: Content-Encoding;gzip;br, Content-Language;en ;fr
Variant-Key: gzip, fr
]]></artwork></figure>

<t>This header pair indicates that the representation is used for responses that have a “gzip” content-coding and “fr” content-language.</t>

<t>Note that the contents of Variant-Key are only used to indicate what request attributes are identified with the response containing it; this is different from headers like Content-Encoding, which indicate attributes of the response. In the example above, it might be that a gzip’d version of the French content is not available, in which case it will not include “Content-Encoding: gzip”, but still have “gzip” in Variant-Key.</t>

<section anchor="gen-variant-key" title="Generating a Normalised Variant-Key">

<t>This algorithm generates a normalised string for Variant-Key, suitable for comparison with values generated by <xref target="cache"/>.</t>

<t>Given stored-headers, a set of headers from a stored response, a normalised variant-key for that message can be generated by:</t>

<t><list style="numbers">
  <t>Let variant-key-header be a string, the result of selecting all field-values of stored-headers whose field-name is “Variant-Key” and joining them with a comma (“,”).</t>
  <t>Remove all whitespace from variant-key-header.</t>
  <t>Return variant-key-header.</t>
</list></t>

</section>
</section>
<section anchor="define" title="Defining Content Negotiation Using Variants">

<t>To be usable with Variants, proactive content negotiation mechanisms need to be specified to take advantage of it. Specifically, they:</t>

<t><list style="symbols">
  <t>MUST define a request header field that advertises the clients preferences or capabilities, whose field-name SHOULD begin with “Accept-“.</t>
  <t>MUST define the syntax of available-values that will occur in Variants and Variant-Key.</t>
  <t>MUST define an algorithm for selecting a result. It MUST return a list of available-values that are suitable for the request, in order of preference, given the value of the request header nominated above and an available-values list from the Variants header. If the result is an empty list, it implies that the cache cannot satisfy the request.</t>
</list></t>

<t><xref target="backports"/> fulfils these requirements for some existing proactive content negotiation mechanisms in HTTP.</t>

</section>
<section anchor="cache" title="Cache Behaviour">

<t>Caches that implement the Variants header field and the relevant semantics of the field-name it contains can use that knowledge to either select an appropriate stored representation, or forward the request if no appropriate representation is stored.</t>

<t>They do so by running this algorithm (or its functional equivalent) upon receiving a request, incoming-request:</t>

<t><list style="numbers">
  <t>Let selected-responses be a list of the stored responses suitable for reuse as defined in <xref target="RFC7234"/> Section 4, excepting the requirement to calculate a secondary cache key.</t>
  <t>If selected-responses is empty, return an empty list.</t>
  <t>Order selected-responses by the “Date” header field, most recent to least recent.</t>
  <t>If the freshest (as per <xref target="RFC7234"/>, Section 4.2) has one or more “Variants” header field(s):
  <list style="numbers">
      <t>Select one member of selected_responses and let its “Variants” header field-value(s) be variants-header. This SHOULD be the most recent response, but MAY be from an older one as long as it is still fresh.</t>
      <t>Let sorted-variants be an empty list.</t>
      <t>For each variant in variants-header:
      <list style="numbers">
          <t>If variant’s field-name corresponds to the request header field identified by a content negotiation mechanism that the implementation supports:
          <list style="numbers">
              <t>Let request-value be the field-value(s) associated with field-name in incoming-request.</t>
              <t>Let available-values be a list containing all available-value for variant.</t>
              <t>Let sorted-values be the result of running the algorithm defined by the content negotiation mechanism with request-value and available-values.</t>
              <t>Append sorted-values to sorted-variants.</t>
            </list></t>
        </list>
At this point, sorted-variants will be a list of lists, each member of the top-level list corresponding to a variant-item in the Variants header field-value, containing zero or more items indicating available-values that are acceptable to the client, in order of preference, greatest to least.</t>
      <t>Let sorted-keys be the result of running Find Available Keys (<xref target="find"/>) on sorted-variants, an empty string and an empty list.</t>
    </list></t>
</list></t>

<t>This will result in a list of strings, where each member of the list indicates, in client preference order, a key for an acceptable response to the request.</t>

<t>A Cache MAY satisfy the request with any response whose Variant-Key header, after normalisation (see <xref target="gen-variant-key"/>), is a character-for-character match of a member of sorted-keys. When doing so, it SHOULD use the most preferred available response, but MAY use a less-preferred response.</t>

<t>See also <xref target="vary"/> regarding handling of Vary.</t>

<section anchor="find" title="Find Available Keys">

<t>Given sorted-variants, a list of lists, and key-stub, a string representing a partial key, and possible-keys, a list:</t>

<t><list style="numbers">
  <t>Let sorted-values be the first member of sorted-variants.</t>
  <t>For each sorted-value in sorted-values:
  <list style="numbers">
      <t>If key-stub is an empty string, let this-key be a copy of sorted-value.</t>
      <t>Otherwise:
      <list style="numbers">
          <t>Let this-key be a copy of key-stub.</t>
          <t>Append a comma (“,”) to this-key.</t>
          <t>Append sorted-value to this-key.</t>
        </list></t>
      <t>Let remaining-variants be a copy of all of the members of sorted-variants except the first.</t>
      <t>If remaining-variants is empty, append this-key to possible-keys.</t>
      <t>Otherwise, run Find Available Keys on remaining-variants, this-key and possible-keys.</t>
    </list></t>
  <t>Return possible-keys.</t>
</list></t>

</section>
<section anchor="example-of-cache-behaviour" title="Example of Cache Behaviour">

<t>For example, if the selected variants-header was:</t>

<figure><artwork><![CDATA[
Variants: Accept-Language;en;fr,de, Accept-Encoding;gzip,br
]]></artwork></figure>

<t>and the request contained the headers:</t>

<figure><artwork><![CDATA[
Accept-Language: fr;q=1.0, en;q=0.1
Accept-Encoding: gzip
]]></artwork></figure>

<t>Then the sorted-variants would be:</t>

<figure><artwork><![CDATA[
[
  ["fr", "en"]           // prefers French, will accept English
  ["gzip", "identity"]   // prefers gzip encoding, will accept identity
]
]]></artwork></figure>

<t>Which means that the sorted-keys would be:</t>

<figure><artwork><![CDATA[
[
  'fr gzip', 
  'fr identity', 
  'en gzip', 
  'en identity'
]
]]></artwork></figure>

<t>Representing a first preference of a French, gzip’d response. Thus, if a cache has a response with:</t>

<figure><artwork><![CDATA[
Variant-Key: fr, gzip
]]></artwork></figure>

<t>it could be used to satisfy the first preference. If not, responses corresponding to the other keys could be returned, or the request could be forwarded towards the origin.</t>

</section>
</section>
<section anchor="examples" title="Example Headers">

<section anchor="single-variant" title="Single Variant">

<t>Given a request/response pair:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Cache-Control: max-age=3600
Variants: Content-Language;en;de
Variant-Key: en
Vary: Accept-Language
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Upon receipt of this response, the cache knows that two representations of this resource are available, one with a <spanx style="verb">Content-Language</spanx> of “en”, and another whose <spanx style="verb">Content-Language</spanx> is “de”.</t>

<t>Subsequent requests (while this response is fresh) will cause the cache to either reuse this response or forward the request, depending on what the selection algorithm determines.</t>

<t>So, if a request with “en” in <spanx style="verb">Accept-Language</spanx> is received and its q-value indicates that it is acceptable, the stored response is used. A request that indicates that “de” is acceptable will be forwarded to the origin, thereby populating the cache. A cache receiving a request that indicates both languages are acceptable will use the q-value to make a determination of what response to return.</t>

<t>A cache receiving a request that does not list either language as acceptable (or does not contain an Accept-Language at all) will return the “en” representation (possibly fetching it from the origin), since it is listed first in the <spanx style="verb">Variants</spanx> list.</t>

<t>Note that <spanx style="verb">Accept-Language</spanx> is listed in Vary, to assure backwards-compatibility with caches that do not support <spanx style="verb">Variants</spanx>.</t>

</section>
<section anchor="multiple-variants" title="Multiple Variants">

<t>A more complicated request/response pair:</t>

<figure><artwork><![CDATA[
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Language;en;jp;de
Variants: Content-Encoding;br;gzip
Variant-Key: en, br
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache knows that there are two axes that the response varies upon; <spanx style="verb">Content-Language</spanx> and <spanx style="verb">Content-Encoding</spanx>. Thus, there are a total of nine possible representations for the resource (including the <spanx style="verb">identity</spanx> encoding), and the cache needs to consider the selection algorithms for both axes.</t>

<t>Upon a subsequent request, if both selection algorithms return a stored representation, it can be served from cache; otherwise, the request will need to be forwarded to origin.</t>

</section>
<section anchor="partial-coverage" title="Partial Coverage">

<t>Now, consider the previous example, but where only one of the Vary’d axes is listed in <spanx style="verb">Variants</spanx>:</t>

<figure><artwork><![CDATA[
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Encoding;br;gzip
Variant-Key: br
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache will need to calculate a secondary cache key as per <xref target="RFC7234"/>, Section 4.1 – but considering only <spanx style="verb">Accept-Language</spanx> to be in its field-value – and then continue processing <spanx style="verb">Variants</spanx> for the set of stored responses that the algorithm described there selects.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This specification registers two values in the Permanent Message Header Field Names registry established by <xref target="RFC3864"/>:</t>

<t><list style="symbols">
  <t>Header field name: Variants</t>
  <t>Applicable protocol: http</t>
  <t>Status: standard</t>
  <t>Author/Change Controller: IETF</t>
  <t>Specification document(s): [this document]</t>
  <t>Related information:</t>
  <t>Header field name: Variant-Key</t>
  <t>Applicable protocol: http</t>
  <t>Status: standard</t>
  <t>Author/Change Controller: IETF</t>
  <t>Specification document(s): [this document]</t>
  <t>Related information:</t>
</list></t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>If the number or advertised characteristics of the representations available for a resource are considered sensitive, the <spanx style="verb">Variants</spanx> header by its nature will leak them.</t>

<t>Note that the <spanx style="verb">Variants</spanx> header is not a commitment to make representations of a certain nature available; the runtime behaviour of the server always overrides hints like <spanx style="verb">Variants</spanx>.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>This protocol is conceptually similar to, but simpler than, Transparent Content Negotiation <xref target="RFC2295"/>. Thanks to its authors for their inspiration.</t>

<t>It is also a generalisation of a Fastly VCL feature designed by Rogier ‘DocWilco’ Mulhuijzen.</t>

<t>Thanks to Hooman Beheshti for his review and input.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC7231" target='https://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference  anchor="RFC7234" target='https://www.rfc-editor.org/info/rfc7234'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.</t></abstract>
</front>
<seriesInfo name='RFC' value='7234'/>
<seriesInfo name='DOI' value='10.17487/RFC7234'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC4647" target='https://www.rfc-editor.org/info/rfc4647'>
<front>
<title>Matching of Language Tags</title>
<author initials='A.' surname='Phillips' fullname='A. Phillips'><organization /></author>
<author initials='M.' surname='Davis' fullname='M. Davis'><organization /></author>
<date year='2006' month='September' />
<abstract><t>This document describes a syntax, called a &quot;language-range&quot;, for specifying items in a user's list of language preferences.  It also describes different mechanisms for comparing and matching these to language tags.  Two kinds of matching mechanisms, filtering and lookup, are defined.  Filtering produces a (potentially empty) set of language tags, whereas lookup produces a single language tag. Possible applications include language negotiation or content selection.  This document, in combination with RFC 4646, replaces RFC 3066, which replaced RFC 1766.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='47'/>
<seriesInfo name='RFC' value='4647'/>
<seriesInfo name='DOI' value='10.17487/RFC4647'/>
</reference>




    </references>

    <references title='Informative References'>





<reference anchor="I-D.ietf-httpbis-client-hints">
<front>
<title>HTTP Client Hints</title>

<author initials='I' surname='Grigorik' fullname='Ilya Grigorik'>
    <organization />
</author>

<date month='January' day='26' year='2018' />

<abstract><t>An increasing diversity of Web-connected devices and software capabilities has created a need to deliver optimized content for each device.  This specification defines an extensible and configurable set of HTTP request header fields, colloquially known as Client Hints, to address this.  They are intended to be used as input to proactive content negotiation; just as the Accept header field allows user agents to indicate what formats they prefer, Client Hints allow user agents to indicate device and agent specific preferences.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-client-hints-05' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-client-hints-05.txt' />
</reference>



<reference  anchor="RFC2295" target='https://www.rfc-editor.org/info/rfc2295'>
<front>
<title>Transparent Content Negotiation in HTTP</title>
<author initials='K.' surname='Holtman' fullname='K. Holtman'><organization /></author>
<author initials='A.' surname='Mutz' fullname='A. Mutz'><organization /></author>
<date year='1998' month='March' />
<abstract><t>HTTP allows web site authors to put multiple versions of the same information under a single URL.  Transparent content negotiation is an extensible negotiation mechanism, layered on top of HTTP, for automatically selecting the best version when the URL is accessed.  This enables the smooth deployment of new web data formats and markup tags. This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind.  Discussion and suggestions for improvement are requested.</t></abstract>
</front>
<seriesInfo name='RFC' value='2295'/>
<seriesInfo name='DOI' value='10.17487/RFC2295'/>
</reference>



<reference  anchor="RFC3864" target='https://www.rfc-editor.org/info/rfc3864'>
<front>
<title>Registration Procedures for Message Header Fields</title>
<author initials='G.' surname='Klyne' fullname='G. Klyne'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<author initials='J.' surname='Mogul' fullname='J. Mogul'><organization /></author>
<date year='2004' month='September' />
<abstract><t>This specification defines registration procedures for the message header fields used by Internet mail, HTTP, Netnews and other applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='90'/>
<seriesInfo name='RFC' value='3864'/>
<seriesInfo name='DOI' value='10.17487/RFC3864'/>
</reference>




    </references>


<section anchor="backports" title="Variants for Existing Content Negotiation Mechanisms">

<t>This appendix defines the required information to use existing proactive content negotiation mechanisms (as defined in <xref target="RFC7231"/>, Section 5.3) with the <spanx style="verb">Variants</spanx> header field.</t>

<section anchor="content-type" title="Accept">

<t>This section defines handling for <spanx style="verb">Accept</spanx> variants, as per <xref target="RFC7231"/> Section 5.3.2.</t>

<t>To perform content negotiation for Accept given a request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-available be an empty list.</t>
  <t>Let preferred-types be a list of the types in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.2 (omitting any coding with a weight of 0). If “Accept” is not present or empty, preferred-types will be empty. If a type lacks an explicit weight, an implementation MAY assign one.</t>
  <t>If preferred-types is empty, append “<spanx style="emph">/</spanx>”.</t>
  <t>For each preferred-type in preferred-types:
  <list style="numbers">
      <t>If any member of available-values matches preferred-type, using the media-range matching mechanism specified in <xref target="RFC7231"/> Section 5.3.2 (which is case-insensitive), append those members of available-values to preferred-available (preserving the precedence order implied by the media ranges’ specificity).</t>
    </list></t>
  <t>Return preferred-available.</t>
</list></t>

<t>Note that this algorithm explicitly ignores extension parameters on media types (e.g., “charset”).</t>

</section>
<section anchor="content-encoding" title="Accept-Encoding">

<t>This section defines handling for <spanx style="verb">Accept-Encoding</spanx> variants, as per <xref target="RFC7231"/> Section 5.3.4.</t>

<t>To perform content negotiation for Accept-Encoding given a request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-available be an empty list.</t>
  <t>Let preferred-codings be a list of the codings in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.1 (omitting any coding with a weight of 0). If “Accept-Encoding” is not present or empty, preferred-codings will be empty. If a coding lacks an explicit weight, an implementation MAY assign one.</t>
  <t>If “identity” is not a member of preferred-codings, append “identity”.</t>
  <t>Append “identity” to available-values.</t>
  <t>For each preferred-coding in preferred-codings:
  <list style="numbers">
      <t>If there is a case-insensitive, character-for-character match for preferred-coding in available-values, append that member of available-values to preferred-available.</t>
    </list></t>
  <t>Return preferred-available.</t>
</list></t>

</section>
<section anchor="content-language" title="Accept-Language">

<t>This section defines handling for <spanx style="verb">Accept-Language</spanx> variants, as per <xref target="RFC7231"/> Section 5.3.5.</t>

<t>To perform content negotiation for Accept-Language given a request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-available be an empty list.</t>
  <t>Let preferred-langs be a list of the language-ranges in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.1 (omitting any language-range with a weight of 0). If a language-range lacks a weight, an implementation MAY assign one.</t>
  <t>Append the first member of available-values to preferred-langs (thus making it the default).</t>
  <t>For each preferred-lang in preferred-langs:
  <list style="numbers">
      <t>If any member of available-values matches preferred-lang, using either the Basic or Extended Filtering scheme defined in <xref target="RFC4647"/> Section 3.3, append those members of available-values to preferred-available (preserving their order).</t>
    </list></t>
  <t>Return preferred-available.</t>
</list></t>

</section>
</section>


  </back>

<!-- ##markdown-source:
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

-->

</rfc>

