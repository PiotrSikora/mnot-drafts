<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.1.2 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-variants-02" category="std" updates="7234">

  <front>
    <title>HTTP Representation Variants</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date year="2018"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification introduces an alternative way to communicate a secondary cache key for a HTTP resource, using the HTTP “Variants” and “Variant-Key” response header fields. Its aim is to make HTTP proactive content negotiation more cache-friendly.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/variants">https://github.com/mnot/I-D/labels/variants</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/variants/">https://mnot.github.io/I-D/variants/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/variants">https://github.com/mnot/I-D/commits/gh-pages/variants</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-variants/">https://datatracker.ietf.org/doc/draft-nottingham-variants/</eref>.</t>

<t>There is a prototype implementation of the algorithms herein at <eref target="https://github.com/mnot/variants-toy">https://github.com/mnot/variants-toy</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP proactive content negotiation (<xref target="RFC7231"/>, Section 3.4.1) is seeing renewed interest, both for existing request headers like Content-Language and for newer ones (for example, see <xref target="I-D.ietf-httpbis-client-hints"/>).</t>

<t>Successfully reusing negotiated responses that have been stored in a HTTP cache requires establishment of a secondary cache key (<xref target="RFC7234"/>, Section 4.1). Currently, the Vary header (<xref target="RFC7231"/>, Section 7.1.4) does this by nominating a set of request headers.</t>

<t>HTTP’s caching model allows a certain amount of latitude in normalising those request header field values, so as to increase the chances of a cache hit while still respecting the semantics of that header. However, normalisation is not formally defined, leading to divergence in cache behaviours.</t>

<t>Even when the headers’ semantics are understood, a cache does not know enough about the possible alternative representations available on the origin server to make an appropriate decision.</t>

<t>For example, if a cache has stored the following request/response pair:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: text/html
Content-Language: fr
Vary: Accept-Language
Transfer-Encoding: chunked

[French content]
]]></artwork></figure>

<t>Provided that the cache has full knowledge of the semantics of Accept-Language and Content-Language, it will know that a French representation is available and might be able to infer that an English representation is not available. But, it does not know (for example) whether a Japanese representation is available without making another request, incurring possibly unnecessary latency.</t>

<t>This specification introduces the HTTP Variants response header field (<xref target="variants"/>) to enumerate the available variant representations on the origin server, to provide clients and caches with enough information to properly satisfy requests – either by selecting a response from cache or by forwarding the request towards the origin – by following the algorithm defined in <xref target="cache"/>.</t>

<t>Its companion the Variant-Key response header field (<xref target="variant-key"/>) indicates which representation was selected, so that it can be reliably reused in the future. When this specification is in use, the example above might become:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: text/html
Content-Language: fr
Vary: Accept-Language
Variants: Accept-Language;fr;de;en;jp
Variant-Key: fr
Transfer-Encoding: chunked

[French content]
]]></artwork></figure>

<t>Proactive content negotiation mechanisms that wish to be used with Variants need to define how to do so explicitly; see <xref target="define"/>. As a result, it is best suited for negotiation over request headers that are well-understood.</t>

<t>Variants also works best when content negotiation takes place over a constrained set of representations; since each variant needs to be listed in the header field, it is ill-suited for open-ended sets of representations.</t>

<t>Variants can be seen as a simpler version of the Alternates header field introduced by <xref target="RFC2295"/>; unlike that mechanism, Variants does not require specification of each combination of attributes, and does not assume that each combination has a unique URL.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

<t>This specification uses the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/> with a list extension, defined in Section 7 of <xref target="RFC7230"/>, that allows for compact definition of comma-separated lists using a ‘#’ operator (similar to how the ‘*’ operator indicates repetition).</t>

<t>Additionally, it uses the “field-name”, “OWS” and “token” rules from <xref target="RFC7230"/>.</t>

</section>
</section>
<section anchor="variants" title="The “Variants” HTTP Header Field">

<t>The Variants HTTP response header field indicates what representations are available for a given resource at the time that the response is produced, by enumerating the request header fields that it varies on, along with the values that are available for each.</t>

<figure><artwork><![CDATA[
Variants        = 1#variant-item
variant-item    = field-name *( OWS ";" OWS available-value )
available-value = token
]]></artwork></figure>

<t>Each “variant-item” indicates a request header field that carries a value that clients might proactively negotiate for; each parameter on it indicates a value for which there is an available representation on the origin server.</t>

<t>So, given this example header field:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip
]]></artwork></figure>

<t>a recipient can infer that the only content-coding available for that resource is “gzip” (along with the “identity” non-encoding; see <xref target="content-encoding"/>).</t>

<t>Given:</t>

<figure><artwork><![CDATA[
Variants: accept-encoding
]]></artwork></figure>

<t>a recipient can infer that no content-codings (beyond identity) are supported. Note that as always, field-name is case-insensitive.</t>

<t>A more complex example:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip;br, Accept-Language;en ;fr
]]></artwork></figure>

<t>Here, recipients can infer that two content-codings in addition to “identity” are available, as well as two content languages. Note that, as with all HTTP header fields that use the “#” list rule (see <xref target="RFC7230"/>, Section 7), they might occur in the same header field or separately, like this:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip;brotli
Variants: Accept-Language;en ;fr
]]></artwork></figure>

<t>The ordering of available-values after the field-name is significant, as it might be used by the header’s algorithm for selecting a response (in this example, the first language is the default; see <xref target="content-language"/>).</t>

<t>The ordering of the request header fields themselves indicates descending application of preferences; in the example above, a cache that has all of the possible permutations stored will honour the client’s preferences for Accept-Encoding before honouring Accept-Language.</t>

<t>Origin servers SHOULD consistently send Variant header fields on all cacheable (as per <xref target="RFC7234"/>, Section 3) responses for a resource, since its absence will trigger caches to fall back to Vary processing.</t>

<t>Likewise, servers MUST send the Variant-Key response header field when sending Variants, since its absence means that the stored response will not be reused when this specification is implemented.</t>

<section anchor="vary" title="Relationship to Vary">

<t>Caches that implement this specification SHOULD ignore request header fields in the Vary header for the purposes of secondary cache key calculation (<xref target="RFC7234"/>, Section 4.1) when their semantics are implemented as per this specification and their corresponding response header field is listed in Variants.</t>

<t>If any member of the Vary header does not have a corresponding variant that is understood by the implementation, it is still subject to the requirements there.</t>

<t>See <xref target="partial"/> for an example.</t>

<t>In practice, implementation of Vary varies considerably. As a result, cache efficiency might drop considerably when Variants does not contain all of the headers referenced by Vary, because some implementations might choose to disable Variants processing when this is the case.</t>

</section>
</section>
<section anchor="variant-key" title="The “Variant-Key” HTTP Header Field">

<t>The Variant-Key HTTP response header field is used to indicate the value(s) from the Variants header field that identify the representation it occurs within.</t>

<figure><artwork><![CDATA[
Variant-Key     = 1#available-value
]]></artwork></figure>

<t>Each value indicates the selected available-value, in the same order as the variants listed in the Variants header field.</t>

<t>Therefore, Variant-Key MUST be the same length (in comma-separated members) as Variants, and each member MUST correspond in position to its companion in Variants.</t>

<t>For example:</t>

<figure><artwork><![CDATA[
Variants: Content-Encoding;gzip;br, Content-Language;en ;fr
Variant-Key: gzip, fr
]]></artwork></figure>

<t>This header pair indicates that the representation has a “gzip” content-coding and “fr” content-language.</t>

<t>Note that Variant-Key is only used to indicate what request attributes are associated with the response containing it; this is different from headers like Content-Encoding, which indicate attributes of the response itself. In the example above, it might be that a gzip’d version of the French content is not available, in which case the response will include:</t>

<figure><artwork><![CDATA[
Variant-Key: gzip, fr
]]></artwork></figure>

<t>even though Content-Encoding does not contain “gzip”.</t>

<section anchor="gen-variant-key" title="Generating a Normalised Variant-Key">

<t>This algorithm generates a normalised string for Variant-Key, suitable for comparison with values generated by <xref target="cache"/>.</t>

<t>Given stored-headers, a set of headers from a stored response, a normalised variant-key for that message can be generated by:</t>

<t><list style="numbers">
  <t>Let variant-key-header be a string, the result of selecting all field-values of stored-headers whose field-name is “Variant-Key” and joining them with a comma (“,”).</t>
  <t>Remove all whitespace from variant-key-header.</t>
  <t>Return variant-key-header.</t>
</list></t>

</section>
</section>
<section anchor="define" title="Defining Content Negotiation Using Variants">

<t>To be usable with Variants, proactive content negotiation mechanisms need to be specified to take advantage of it. Specifically, they:</t>

<t><list style="symbols">
  <t>MUST define a request header field that advertises the clients preferences or capabilities, whose field-name SHOULD begin with “Accept-“.</t>
  <t>MUST define the syntax of available-values that will occur in Variants and Variant-Key.</t>
  <t>MUST define an algorithm for selecting a result. It MUST return a list of available-values that are suitable for the request, in order of preference, given the value of the request header nominated above and an available-values list from the Variants header. If the result is an empty list, it implies that the cache cannot satisfy the request.</t>
</list></t>

<t><xref target="backports"/> fulfils these requirements for some existing proactive content negotiation mechanisms in HTTP.</t>

</section>
<section anchor="cache" title="Cache Behaviour">

<t>Caches that implement the Variants header field and the relevant semantics of the field-name it contains can use that knowledge to either select an appropriate stored representation, or forward the request if no appropriate representation is stored.</t>

<t>They do so by running this algorithm (or its functional equivalent) upon receiving a request:</t>

<t>Given incoming-request, a mapping of field-names to lists of field values, and stored-responses, a list of stored responses suitable for reuse as defined in <xref target="RFC7234"/> Section 4, excepting the requirement to calculate a secondary cache key:</t>

<t><list style="numbers">
  <t>If stored-responses is empty, return an empty list.</t>
  <t>Order stored-responses by the “Date” header field, most recent to least recent.</t>
  <t>Let sorted-variants be an empty list.</t>
  <t>If the freshest member of stored-responses (as per <xref target="RFC7234"/>, Section 4.2) has one or more “Variants” header field(s):
  <list style="numbers">
      <t>Select one member of stored-responses and let its “Variants” header field-value(s) be variants-header. This SHOULD be the most recent response, but MAY be from an older one as long as it is still fresh.</t>
      <t>For each variant in variants-header:
      <list style="numbers">
          <t>If variant’s field-name corresponds to the request header field identified by a content negotiation mechanism that the implementation supports:
          <list style="numbers">
              <t>Let request-value be the field-value(s) associated with field-name in incoming-request.</t>
              <t>Let available-values be a list containing all available-value for variant.</t>
              <t>Let sorted-values be the result of running the algorithm defined by the content negotiation mechanism with request-value and available-values.</t>
              <t>Append sorted-values to sorted-variants.</t>
            </list></t>
        </list>
At this point, sorted-variants will be a list of lists, each member of the top-level list corresponding to a variant-item in the Variants header field-value, containing zero or more items indicating available-values that are acceptable to the client, in order of preference, greatest to least.</t>
    </list></t>
  <t>Return result of running Find Available Keys (<xref target="find"/>) on sorted-variants, an empty string and an empty list.</t>
</list></t>

<t>This returns a list of strings suitable for comparing to normalised Variant-Keys (<xref target="gen-variant-key"/>) that represent possible responses on the server that can be used to satisfy the request, in preference order, provided that their secondary cache key (after removing the headers covered by Variants) matches. <xref target="check_vary"/> illustrates one way to do this.</t>

<section anchor="find" title="Find Available Keys">

<t>Given sorted-variants, a list of lists, and key-stub, a string representing a partial key, and possible-keys, a list:</t>

<t><list style="numbers">
  <t>Let sorted-values be the first member of sorted-variants.</t>
  <t>For each sorted-value in sorted-values:
  <list style="numbers">
      <t>If key-stub is an empty string, let this-key be a copy of sorted-value.</t>
      <t>Otherwise:
      <list style="numbers">
          <t>Let this-key be a copy of key-stub.</t>
          <t>Append a comma (“,”) to this-key.</t>
          <t>Append sorted-value to this-key.</t>
        </list></t>
      <t>Let remaining-variants be a copy of all of the members of sorted-variants except the first.</t>
      <t>If remaining-variants is empty, append this-key to possible-keys.</t>
      <t>Otherwise, run Find Available Keys on remaining-variants, this-key and possible-keys.</t>
    </list></t>
  <t>Return possible-keys.</t>
</list></t>

</section>
<section anchor="check_vary" title="Check Vary">

<t>This algorithm is an example of how an implementation can meet the requirement to apply the members of the Vary header field that are not covered by Variants.</t>

<t>Given a stored response, stored-response:</t>

<t><list style="numbers">
  <t>Let filtered-vary be the field-value(s) of stored-response’s “Vary” header field.</t>
  <t>Let processed-variants be a list containing the request header fields that identify the content negotiation mechanisms supported by the implementation.</t>
  <t>Remove any member of filtered-vary that is a case-insensitive match for a member of processed-variants.</t>
  <t>If the secondary cache key (as calculated in <xref target="RFC7234"/>, Section 4.1) for stored_response matches incoming-request, using filtered-vary for the value of the “Vary” response header, return True.</t>
  <t>Return False.</t>
</list></t>

<t>This returns a Boolean that indicates whether stored-response can be used to satisfy the request.</t>

<t>Note that implementation of the Vary header field varies in practice, and the algorithm above illustrates only one way to apply it. It is equally viable to forward the request if there is a request header listed in Vary but not Variants.</t>

</section>
<section anchor="example-of-cache-behaviour" title="Example of Cache Behaviour">

<t>For example, if the selected variants-header was:</t>

<figure><artwork><![CDATA[
Variants: Accept-Language;en;fr,de, Accept-Encoding;gzip,br
]]></artwork></figure>

<t>and the request contained the headers:</t>

<figure><artwork><![CDATA[
Accept-Language: fr;q=1.0, en;q=0.1
Accept-Encoding: gzip
]]></artwork></figure>

<t>Then the sorted-variants would be:</t>

<figure><artwork><![CDATA[
[
  ["fr", "en"]           // prefers French, will accept English
  ["gzip", "identity"]   // prefers gzip encoding, will accept identity
]
]]></artwork></figure>

<t>Which means that the sorted-keys would be:</t>

<figure><artwork><![CDATA[
[
  'fr gzip',
  'fr identity',
  'en gzip',
  'en identity'
]
]]></artwork></figure>

<t>Representing a first preference of a French, gzip’d response. Thus, if a cache has a response with:</t>

<figure><artwork><![CDATA[
Variant-Key: fr, gzip
]]></artwork></figure>

<t>it could be used to satisfy the first preference. If not, responses corresponding to the other keys could be returned, or the request could be forwarded towards the origin.</t>

</section>
</section>
<section anchor="origin" title="Origin Server Behaviour">

<t>Origin servers that wish to take advantage of Variants will need to generate both the Variants (<xref target="variants"/>) and Variant-Key (<xref target="variant-key"/>) header fields in all cacheable responses for a given resource. If either is omitted and the response is stored, it will have the effect of disabling caching for that resource until it is no longer stored (e.g., it expires, or is evicted).</t>

<t>Likewise, origin servers will need to assure that the members of both header field values are in the same order and have the same length, since discrepancies will cause caches to avoid using the responses they occur in.</t>

<t>The value of the Variants header should be relatively stable for a given resource over time; when it changes, it can have the effect of invalidating previously stored responses.</t>

<t>As per <xref target="vary"/>, the Vary header is required to be set appropriately when Variants is in use, so that caches that do not implement this specification still operate correctly.</t>

<t>Origin servers are advised to carefully consider which content negotiation mechanisms to enumerate in Variants; if a mechanism is not supported by a receiving cache, it will “downgrade” to Vary handling, which can negatively impact cache efficiency.</t>

<section anchor="examples" title="Examples">

<t>The operation of Variants is illustrated by the examples below.</t>

<section anchor="single-variant" title="Single Variant">

<t>Given a request/response pair:</t>

<figure><artwork><![CDATA[
GET /clancy HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Cache-Control: max-age=3600
Variants: Content-Language;en;de
Variant-Key: en
Vary: Accept-Language
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Upon receipt of this response, the cache knows that two representations of this resource are available, one with a Content-Language of “en”, and another whose Content-Language is “de”.</t>

<t>Subsequent requests (while this response is fresh) will cause the cache to either reuse this response or forward the request, depending on what the selection algorithm determines.</t>

<t>So, if a request with “en” in Accept-Language is received and its q-value indicates that it is acceptable, the stored response is used. A request that indicates that “de” is acceptable will be forwarded to the origin, thereby populating the cache. A cache receiving a request that indicates both languages are acceptable will use the q-value to make a determination of what response to return.</t>

<t>A cache receiving a request that does not list either language as acceptable (or does not contain an Accept-Language at all) will return the “en” representation (possibly fetching it from the origin), since it is listed first in the Variants list.</t>

<t>Note that Accept-Language is listed in Vary, to assure backwards-compatibility with caches that do not support Variants.</t>

</section>
<section anchor="multiple-variants" title="Multiple Variants">

<t>A more complicated request/response pair:</t>

<figure><artwork><![CDATA[
GET /murray HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Language;en;jp;de
Variants: Content-Encoding;br;gzip
Variant-Key: en, br
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache knows that there are two axes that the response varies upon; Content-Language and Content-Encoding. Thus, there are a total of nine possible representations for the resource (including the identity encoding), and the cache needs to consider the selection algorithms for both axes.</t>

<t>Upon a subsequent request, if both selection algorithms return a stored representation, it can be served from cache; otherwise, the request will need to be forwarded to origin.</t>

</section>
<section anchor="partial" title="Partial Coverage">

<t>Now, consider the previous example, but where only one of the Vary’d axes is listed in Variants:</t>

<figure><artwork><![CDATA[
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Encoding;br;gzip
Variant-Key: br
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache will need to calculate a secondary cache key as per <xref target="RFC7234"/>, Section 4.1 – but considering only Accept-Language to be in its field-value – and then continue processing Variants for the set of stored responses that the algorithm described there selects.</t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This specification registers two values in the Permanent Message Header Field Names registry established by <xref target="RFC3864"/>:</t>

<t><list style="symbols">
  <t>Header field name: Variants</t>
  <t>Applicable protocol: http</t>
  <t>Status: standard</t>
  <t>Author/Change Controller: IETF</t>
  <t>Specification document(s): [this document]</t>
  <t>Related information:</t>
  <t>Header field name: Variant-Key</t>
  <t>Applicable protocol: http</t>
  <t>Status: standard</t>
  <t>Author/Change Controller: IETF</t>
  <t>Specification document(s): [this document]</t>
  <t>Related information:</t>
</list></t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>If the number or advertised characteristics of the representations available for a resource are considered sensitive, the Variants header by its nature will leak them.</t>

<t>Note that the Variants header is not a commitment to make representations of a certain nature available; the runtime behaviour of the server always overrides hints like Variants.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>This protocol is conceptually similar to, but simpler than, Transparent Content Negotiation <xref target="RFC2295"/>. Thanks to its authors for their inspiration.</t>

<t>It is also a generalisation of a Fastly VCL feature designed by Rogier ‘DocWilco’ Mulhuijzen.</t>

<t>Thanks to Hooman Beheshti for his review and input.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC7231" target='https://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference  anchor="RFC7234" target='https://www.rfc-editor.org/info/rfc7234'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.</t></abstract>
</front>
<seriesInfo name='RFC' value='7234'/>
<seriesInfo name='DOI' value='10.17487/RFC7234'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC4647" target='https://www.rfc-editor.org/info/rfc4647'>
<front>
<title>Matching of Language Tags</title>
<author initials='A.' surname='Phillips' fullname='A. Phillips'><organization /></author>
<author initials='M.' surname='Davis' fullname='M. Davis'><organization /></author>
<date year='2006' month='September' />
<abstract><t>This document describes a syntax, called a &quot;language-range&quot;, for specifying items in a user's list of language preferences.  It also describes different mechanisms for comparing and matching these to language tags.  Two kinds of matching mechanisms, filtering and lookup, are defined.  Filtering produces a (potentially empty) set of language tags, whereas lookup produces a single language tag. Possible applications include language negotiation or content selection.  This document, in combination with RFC 4646, replaces RFC 3066, which replaced RFC 1766.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='47'/>
<seriesInfo name='RFC' value='4647'/>
<seriesInfo name='DOI' value='10.17487/RFC4647'/>
</reference>




    </references>

    <references title='Informative References'>





<reference anchor="I-D.ietf-httpbis-client-hints">
<front>
<title>HTTP Client Hints</title>

<author initials='I' surname='Grigorik' fullname='Ilya Grigorik'>
    <organization />
</author>

<date month='January' day='26' year='2018' />

<abstract><t>An increasing diversity of Web-connected devices and software capabilities has created a need to deliver optimized content for each device.  This specification defines an extensible and configurable set of HTTP request header fields, colloquially known as Client Hints, to address this.  They are intended to be used as input to proactive content negotiation; just as the Accept header field allows user agents to indicate what formats they prefer, Client Hints allow user agents to indicate device and agent specific preferences.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-client-hints-05' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-client-hints-05.txt' />
</reference>



<reference  anchor="RFC2295" target='https://www.rfc-editor.org/info/rfc2295'>
<front>
<title>Transparent Content Negotiation in HTTP</title>
<author initials='K.' surname='Holtman' fullname='K. Holtman'><organization /></author>
<author initials='A.' surname='Mutz' fullname='A. Mutz'><organization /></author>
<date year='1998' month='March' />
<abstract><t>HTTP allows web site authors to put multiple versions of the same information under a single URL.  Transparent content negotiation is an extensible negotiation mechanism, layered on top of HTTP, for automatically selecting the best version when the URL is accessed.  This enables the smooth deployment of new web data formats and markup tags. This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind.  Discussion and suggestions for improvement are requested.</t></abstract>
</front>
<seriesInfo name='RFC' value='2295'/>
<seriesInfo name='DOI' value='10.17487/RFC2295'/>
</reference>



<reference  anchor="RFC3864" target='https://www.rfc-editor.org/info/rfc3864'>
<front>
<title>Registration Procedures for Message Header Fields</title>
<author initials='G.' surname='Klyne' fullname='G. Klyne'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<author initials='J.' surname='Mogul' fullname='J. Mogul'><organization /></author>
<date year='2004' month='September' />
<abstract><t>This specification defines registration procedures for the message header fields used by Internet mail, HTTP, Netnews and other applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='90'/>
<seriesInfo name='RFC' value='3864'/>
<seriesInfo name='DOI' value='10.17487/RFC3864'/>
</reference>




    </references>


<section anchor="backports" title="Variants for Existing Content Negotiation Mechanisms">

<t>This appendix defines the required information to use existing proactive content negotiation mechanisms (as defined in <xref target="RFC7231"/>, Section 5.3) with the Variants header field.</t>

<section anchor="content-type" title="Accept">

<t>This section defines handling for Accept variants, as per <xref target="RFC7231"/> Section 5.3.2.</t>

<t>To perform content negotiation for Accept given a request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-available be an empty list.</t>
  <t>Let preferred-types be a list of the types in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.2 (omitting any coding with a weight of 0). If “Accept” is not present or empty, preferred-types will be empty. If a type lacks an explicit weight, an implementation MAY assign one.</t>
  <t>If the first member of available-values is not a member of preferred-types, append it to preferred-types (thus making it the default).</t>
  <t>For each preferred-type in preferred-types:
  <list style="numbers">
      <t>If any member of available-values matches preferred-type, using the media-range matching mechanism specified in <xref target="RFC7231"/> Section 5.3.2 (which is case-insensitive), append those members of available-values to preferred-available (preserving the precedence order implied by the media ranges’ specificity).</t>
    </list></t>
  <t>Return preferred-available.</t>
</list></t>

<t>Note that this algorithm explicitly ignores extension parameters on media types (e.g., “charset”).</t>

</section>
<section anchor="content-encoding" title="Accept-Encoding">

<t>This section defines handling for Accept-Encoding variants, as per <xref target="RFC7231"/> Section 5.3.4.</t>

<t>To perform content negotiation for Accept-Encoding given a request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-available be an empty list.</t>
  <t>Let preferred-codings be a list of the codings in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.1 (omitting any coding with a weight of 0). If “Accept-Encoding” is not present or empty, preferred-codings will be empty. If a coding lacks an explicit weight, an implementation MAY assign one.</t>
  <t>If “identity” is not a member of preferred-codings, append “identity”.</t>
  <t>Append “identity” to available-values.</t>
  <t>For each preferred-coding in preferred-codings:
  <list style="numbers">
      <t>If there is a case-insensitive, character-for-character match for preferred-coding in available-values, append that member of available-values to preferred-available.</t>
    </list></t>
  <t>Return preferred-available.</t>
</list></t>

<t>Note that the unencoded variant needs to have a Variant-Key header field with a value of “identity”.</t>

</section>
<section anchor="content-language" title="Accept-Language">

<t>This section defines handling for Accept-Language variants, as per <xref target="RFC7231"/> Section 5.3.5.</t>

<t>To perform content negotiation for Accept-Language given a request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-available be an empty list.</t>
  <t>Let preferred-langs be a list of the language-ranges in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.1 (omitting any language-range with a weight of 0). If a language-range lacks a weight, an implementation MAY assign one.</t>
  <t>If the first member of available-values is not a member of preferred-langs, append it to preferred-langs (thus making it the default).</t>
  <t>For each preferred-lang in preferred-langs:
  <list style="numbers">
      <t>If any member of available-values matches preferred-lang, using either the Basic or Extended Filtering scheme defined in <xref target="RFC4647"/> Section 3.3, append those members of available-values to preferred-available (preserving their order).</t>
    </list></t>
  <t>Return preferred-available.</t>
</list></t>

</section>
</section>


  </back>

<!-- ##markdown-source:
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
5kpkAAA=

-->

</rfc>

