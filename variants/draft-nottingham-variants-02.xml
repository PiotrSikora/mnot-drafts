<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.1.2 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-variants-02" category="std" updates="7234">

  <front>
    <title>HTTP Representation Variants</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date year="2018"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification introduces an alternative way to communicate a secondary cache key for a HTTP resource, using the HTTP “Variants” and “Variant-Key” response header fields. Its aim is to make HTTP proactive content negotiation more cache-friendly.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/variants">https://github.com/mnot/I-D/labels/variants</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/variants/">https://mnot.github.io/I-D/variants/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/variants">https://github.com/mnot/I-D/commits/gh-pages/variants</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-variants/">https://datatracker.ietf.org/doc/draft-nottingham-variants/</eref>.</t>

<t>There is a prototype implementation of the algorithms herein at <eref target="https://github.com/mnot/variants-toy">https://github.com/mnot/variants-toy</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP proactive content negotiation (<xref target="RFC7231"/>, Section 3.4.1) is seeing renewed interest in negotiation for language and other, newer attributes (for example, see <xref target="I-D.ietf-httpbis-client-hints"/>).</t>

<t>Successfully reusing negotiated responses that have been stored in a HTTP cache requires establishment of a secondary cache key (<xref target="RFC7234"/>, Section 4.1). Currently, the Vary header (<xref target="RFC7231"/>, Section 7.1.4) does this by nominating a set of request headers.</t>

<t>HTTP’s caching model allows a certain amount of latitude in normalising request header field values, so as to increase the chances of a cache hit while still respecting the semantics of that header. However, this is often inadequate; even when the headers’ semantics are understood, a cache does not know enough about the possible alternative representations available on the origin server to make an appropriate decision.</t>

<t>For example, if a cache has stored the following request/response pair:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: text/html
Content-Language: fr
Vary: Accept-Language
Transfer-Encoding: chunked

[French content]
]]></artwork></figure>

<t>Provided that the cache has full knowledge of the semantics of Accept-Language and Content-Language, it will know that a French representation is available and might be able to infer that an English representation is not available. But, it does not know (for example) whether a Japanese representation is available without making another request, incurring possibly unnecessary latency.</t>

<t>This specification introduces the HTTP Variants response header field (<xref target="variants"/>) to enumerate the available variant representations on the origin server, to provide clients and caches with enough information to properly satisfy requests – either by selecting a response from cache or by forwarding the request towards the origin – by following an algorithm defined in <xref target="cache"/>.</t>

<t>Its companion the Variant-Key response header field (<xref target="variant-key"/>) indicates which representation was selected, so that it can be reliably reused in the future. When this specification is in use, the example above might become:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: text/html
Content-Language: fr
Vary: Accept-Language
Variants: Accept-Language;fr;de;en;jp
Variant-Key: fr
Transfer-Encoding: chunked

[French content]
]]></artwork></figure>

<t>Proactive content negotiation mechanisms that wish to be used with Variants need to define how to do so explicitly; see <xref target="define"/>. It is best suited for negotiation over request headers that are well-understood. Variants also works best when content negotiation takes place over a constrained set of representations; since each variant needs to be listed in the header field, it is ill-suited for open-ended sets of representations.</t>

<t>Variants can be seen as a simpler version of the Alternates header field introduced by <xref target="RFC2295"/>; unlike that mechanism, Variants does not require specification of each combination of attributes, and does not assume that each combination has a unique URL.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

<t>This specification uses the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/> with a list extension, defined in Section 7 of <xref target="RFC7230"/>, that allows for compact definition of comma-separated lists using a ‘#’ operator (similar to how the ‘*’ operator indicates repetition).</t>

<t>Additionally, it uses the “field-name”, “OWS” and “token” rules from <xref target="RFC7230"/>.</t>

</section>
</section>
<section anchor="variants" title="The “Variants” HTTP Header Field">

<t>The Variants HTTP response header field indicates what representations are available for a given resource at the time that the response is produced, by enumerating the request header fields that it varies on, along with the values that are available for each.</t>

<figure><artwork><![CDATA[
Variants        = 1#variant-item
variant-item    = field-name *( OWS ";" OWS available-value )
available-value = token
]]></artwork></figure>

<t>Each “variant-item” indicates a request header field that carries a value that clients might proactively negotiate for; each parameter on it indicates a value for which there is an available representation on the origin server.</t>

<t>So, given this example header field:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip
]]></artwork></figure>

<t>a recipient can infer that the only content-coding available for that resource is “gzip” (along with the “identity” non-encoding; see <xref target="content-encoding"/>).</t>

<t>Given:</t>

<figure><artwork><![CDATA[
Variants: accept-encoding
]]></artwork></figure>

<t>a recipient can infer that no content-codings (beyond identity) are supported. Note that as always, field-name is case-insensitive.</t>

<t>A more complex example:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip;br, Accept-Language;en ;fr
]]></artwork></figure>

<t>Here, recipients can infer that two content-codings in addition to “identity” are available, as well as two content languages. Note that, as with all HTTP header fields that use the “#” list rule (see <xref target="RFC7230"/>, Section 7), they might occur in the same header field or separately, like this:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip;brotli
Variants: Accept-Language;en ;fr
]]></artwork></figure>

<t>The ordering of available-values after the field-name is significant, as it might be used by the header’s algorithm for selecting a response (see <xref target="content-encoding"/> for an example of this).</t>

<t>The ordering of the request header fields themselves indicates descending application of preferences; for example, in the headers above, a cache will serve gzip’d content regardless of language if it is available.</t>

<t>Origin servers SHOULD consistently send Variant header fields on all cacheable (as per <xref target="RFC7234"/>, Section 3) responses for a resource, since its absence will trigger caches to fall back to Vary processing.</t>

<t>Likewise, servers MUST send the Variant-Key response header field when sending Variants.</t>

<section anchor="vary" title="Relationship to Vary">

<t>Caches that implement this specification SHOULD ignore request header fields in the <spanx style="verb">Vary</spanx> header for the purposes of secondary cache key calculation (<xref target="RFC7234"/>, Section 4.1) when their semantics are implemented as per this specification and their corresponding response header field is listed in <spanx style="verb">Variants</spanx>.</t>

<t>If any member of the Vary header does not have a corresponding variant that is understood by the implementation, it is still subject to the requirements there.</t>

<t>See <xref target="partial"/> for an example.</t>

<t>In practice, implementation of Vary varies considerably. As a result, cache efficiency might drop considerably when Variants does not contain all of the headers referenced by Vary, because some implementations might choose to disable Variants processing when this is the case.</t>

</section>
</section>
<section anchor="variant-key" title="The “Variant-Key” HTTP Header Field">

<t>The Variant-Key HTTP response header field is used to indicate the value(s) from the Variants header field that identify the representation it occurs within.</t>

<figure><artwork><![CDATA[
Variant-Key     = 1#available-value
]]></artwork></figure>

<t>Each value indicates the selected available-value, in the same order as the variants listed in the Variants header field.</t>

<t>Therefore, Variant-Key MUST be the same length (in comma-separated members) as Variants, and each member MUST correspond in position to its companion in Variants.</t>

<t>For example:</t>

<figure><artwork><![CDATA[
Variants: Content-Encoding;gzip;br, Content-Language;en ;fr
Variant-Key: gzip, fr
]]></artwork></figure>

<t>This header pair indicates that the representation is used for responses that have a “gzip” content-coding and “fr” content-language.</t>

<t>Note that the contents of Variant-Key are only used to indicate what request attributes are identified with the response containing it; this is different from headers like Content-Encoding, which indicate attributes of the response. In the example above, it might be that a gzip’d version of the French content is not available, in which case it will not include “Content-Encoding: gzip”, but still have “gzip” in Variant-Key.</t>

<section anchor="gen-variant-key" title="Generating a Normalised Variant-Key">

<t>This algorithm generates a normalised string for Variant-Key, suitable for comparison with values generated by <xref target="cache"/>.</t>

<t>Given stored-headers, a set of headers from a stored response, a normalised variant-key for that message can be generated by:</t>

<t><list style="numbers">
  <t>Let variant-key-header be a string, the result of selecting all field-values of stored-headers whose field-name is “Variant-Key” and joining them with a comma (“,”).</t>
  <t>Remove all whitespace from variant-key-header.</t>
  <t>Return variant-key-header.</t>
</list></t>

</section>
</section>
<section anchor="define" title="Defining Content Negotiation Using Variants">

<t>To be usable with Variants, proactive content negotiation mechanisms need to be specified to take advantage of it. Specifically, they:</t>

<t><list style="symbols">
  <t>MUST define a request header field that advertises the clients preferences or capabilities, whose field-name SHOULD begin with “Accept-“.</t>
  <t>MUST define the syntax of available-values that will occur in Variants and Variant-Key.</t>
  <t>MUST define an algorithm for selecting a result. It MUST return a list of available-values that are suitable for the request, in order of preference, given the value of the request header nominated above and an available-values list from the Variants header. If the result is an empty list, it implies that the cache cannot satisfy the request.</t>
</list></t>

<t><xref target="backports"/> fulfils these requirements for some existing proactive content negotiation mechanisms in HTTP.</t>

</section>
<section anchor="cache" title="Cache Behaviour">

<t>Caches that implement the Variants header field and the relevant semantics of the field-name it contains can use that knowledge to either select an appropriate stored representation, or forward the request if no appropriate representation is stored.</t>

<t>They do so by running this algorithm (or its functional equivalent) upon receiving a request:</t>

<t>Given incoming-request, a mapping of field-names to lists of field values, and stored-responses, a list of stored responses suitable for reuse as defined in <xref target="RFC7234"/> Section 4, excepting the requirement to calculate a secondary cache key:</t>

<t><list style="numbers">
  <t>If stored-responses is empty, return an empty list.</t>
  <t>Order stored-responses by the “Date” header field, most recent to least recent.</t>
  <t>Let processed-variants be an empty list.</t>
  <t>Let sorted-variants be an empty list.</t>
  <t>If the freshest member of stored-responses (as per <xref target="RFC7234"/>, Section 4.2) has one or more “Variants” header field(s):
  <list style="numbers">
      <t>Select one member of stored-responses and let its “Variants” header field-value(s) be variants-header. This SHOULD be the most recent response, but MAY be from an older one as long as it is still fresh.</t>
      <t>For each variant in variants-header:
      <list style="numbers">
          <t>If variant’s field-name corresponds to the request header field identified by a content negotiation mechanism that the implementation supports:
          <list style="numbers">
              <t>Append field-name to processed-variants.</t>
              <t>Let request-value be the field-value(s) associated with field-name in incoming-request.</t>
              <t>Let available-values be a list containing all available-value for variant.</t>
              <t>Let sorted-values be the result of running the algorithm defined by the content negotiation mechanism with request-value and available-values.</t>
              <t>Append sorted-values to sorted-variants.</t>
            </list></t>
        </list>
At this point, sorted-variants will be a list of lists, each member of the top-level list corresponding to a variant-item in the Variants header field-value, containing zero or more items indicating available-values that are acceptable to the client, in order of preference, greatest to least.</t>
    </list></t>
  <t>Let sorted-keys be the result of running Find Available Keys (<xref target="find"/>) on sorted-variants, an empty string and an empty list.</t>
</list></t>

<t>Now, we find the stored responses that match those keys, and do Vary processing for anything that isn’t covered by Variants.</t>

<t><list style="numbers">
  <t>Let acceptable-stored be an empty list.</t>
  <t>For each variant-key in sorted-keys:
  <list style="numbers">
      <t>Let selected-responses be the member(s) of stored-responses whose “Variant-Key” header value after normalization (as per <xref target="gen-variant-key"/>) correspond to variant-key.</t>
      <t>If selected-responses is empty, skip to the next variant-key.</t>
      <t>For each selected-response in selected-responses:
      <list style="numbers">
          <t>Let filtered-vary be the field-value(s) of selected-response’s “Vary” header field.</t>
          <t>Remove any member of filtered-vary that is a case-insensitive match for a member of processed-variants.</t>
          <t>If the secondary cache key (as calculated in <xref target="RFC7234"/>, Section 4.1) for selected-response does not match incoming-request, using filtered-vary for the value of the “Vary” response header, skip to the next variant-key.</t>
          <t>Append selected-response to acceptable-stored.</t>
        </list></t>
    </list></t>
  <t>Return sorted-keys, acceptable-stored.</t>
</list></t>

<t>This returns a tuple of (sorted-keys, acceptable-stored).</t>

<t>sorted-keys is a list of normalised variant-keys that could satisfy incoming-request, regardless of whether they are stored in the cache. This information can be used to determine if forwarding the request would result in a usable response.</t>

<t>acceptable-stored is the subset of stored-responses, in client preference order, that can be used to satisfy incoming-request. If the list is empty, there is not a suitable stored response.</t>

<t>Note that implementation of the Vary header field varies in practice, and the algorithm above illustrates only one way to apply it.</t>

<section anchor="find" title="Find Available Keys">

<t>Given sorted-variants, a list of lists, and key-stub, a string representing a partial key, and possible-keys, a list:</t>

<t><list style="numbers">
  <t>Let sorted-values be the first member of sorted-variants.</t>
  <t>For each sorted-value in sorted-values:
  <list style="numbers">
      <t>If key-stub is an empty string, let this-key be a copy of sorted-value.</t>
      <t>Otherwise:
      <list style="numbers">
          <t>Let this-key be a copy of key-stub.</t>
          <t>Append a comma (“,”) to this-key.</t>
          <t>Append sorted-value to this-key.</t>
        </list></t>
      <t>Let remaining-variants be a copy of all of the members of sorted-variants except the first.</t>
      <t>If remaining-variants is empty, append this-key to possible-keys.</t>
      <t>Otherwise, run Find Available Keys on remaining-variants, this-key and possible-keys.</t>
    </list></t>
  <t>Return possible-keys.</t>
</list></t>

</section>
<section anchor="example-of-cache-behaviour" title="Example of Cache Behaviour">

<t>For example, if the selected variants-header was:</t>

<figure><artwork><![CDATA[
Variants: Accept-Language;en;fr,de, Accept-Encoding;gzip,br
]]></artwork></figure>

<t>and the request contained the headers:</t>

<figure><artwork><![CDATA[
Accept-Language: fr;q=1.0, en;q=0.1
Accept-Encoding: gzip
]]></artwork></figure>

<t>Then the sorted-variants would be:</t>

<figure><artwork><![CDATA[
[
  ["fr", "en"]           // prefers French, will accept English
  ["gzip", "identity"]   // prefers gzip encoding, will accept identity
]
]]></artwork></figure>

<t>Which means that the sorted-keys would be:</t>

<figure><artwork><![CDATA[
[
  'fr gzip', 
  'fr identity', 
  'en gzip', 
  'en identity'
]
]]></artwork></figure>

<t>Representing a first preference of a French, gzip’d response. Thus, if a cache has a response with:</t>

<figure><artwork><![CDATA[
Variant-Key: fr, gzip
]]></artwork></figure>

<t>it could be used to satisfy the first preference. If not, responses corresponding to the other keys could be returned, or the request could be forwarded towards the origin.</t>

</section>
</section>
<section anchor="examples" title="Example Headers">

<section anchor="single-variant" title="Single Variant">

<t>Given a request/response pair:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Cache-Control: max-age=3600
Variants: Content-Language;en;de
Variant-Key: en
Vary: Accept-Language
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Upon receipt of this response, the cache knows that two representations of this resource are available, one with a <spanx style="verb">Content-Language</spanx> of “en”, and another whose <spanx style="verb">Content-Language</spanx> is “de”.</t>

<t>Subsequent requests (while this response is fresh) will cause the cache to either reuse this response or forward the request, depending on what the selection algorithm determines.</t>

<t>So, if a request with “en” in <spanx style="verb">Accept-Language</spanx> is received and its q-value indicates that it is acceptable, the stored response is used. A request that indicates that “de” is acceptable will be forwarded to the origin, thereby populating the cache. A cache receiving a request that indicates both languages are acceptable will use the q-value to make a determination of what response to return.</t>

<t>A cache receiving a request that does not list either language as acceptable (or does not contain an Accept-Language at all) will return the “en” representation (possibly fetching it from the origin), since it is listed first in the <spanx style="verb">Variants</spanx> list.</t>

<t>Note that <spanx style="verb">Accept-Language</spanx> is listed in Vary, to assure backwards-compatibility with caches that do not support <spanx style="verb">Variants</spanx>.</t>

</section>
<section anchor="multiple-variants" title="Multiple Variants">

<t>A more complicated request/response pair:</t>

<figure><artwork><![CDATA[
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Language;en;jp;de
Variants: Content-Encoding;br;gzip
Variant-Key: en, br
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache knows that there are two axes that the response varies upon; <spanx style="verb">Content-Language</spanx> and <spanx style="verb">Content-Encoding</spanx>. Thus, there are a total of nine possible representations for the resource (including the <spanx style="verb">identity</spanx> encoding), and the cache needs to consider the selection algorithms for both axes.</t>

<t>Upon a subsequent request, if both selection algorithms return a stored representation, it can be served from cache; otherwise, the request will need to be forwarded to origin.</t>

</section>
<section anchor="partial" title="Partial Coverage">

<t>Now, consider the previous example, but where only one of the Vary’d axes is listed in <spanx style="verb">Variants</spanx>:</t>

<figure><artwork><![CDATA[
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Encoding;br;gzip
Variant-Key: br
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache will need to calculate a secondary cache key as per <xref target="RFC7234"/>, Section 4.1 – but considering only <spanx style="verb">Accept-Language</spanx> to be in its field-value – and then continue processing <spanx style="verb">Variants</spanx> for the set of stored responses that the algorithm described there selects.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This specification registers two values in the Permanent Message Header Field Names registry established by <xref target="RFC3864"/>:</t>

<t><list style="symbols">
  <t>Header field name: Variants</t>
  <t>Applicable protocol: http</t>
  <t>Status: standard</t>
  <t>Author/Change Controller: IETF</t>
  <t>Specification document(s): [this document]</t>
  <t>Related information:</t>
  <t>Header field name: Variant-Key</t>
  <t>Applicable protocol: http</t>
  <t>Status: standard</t>
  <t>Author/Change Controller: IETF</t>
  <t>Specification document(s): [this document]</t>
  <t>Related information:</t>
</list></t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>If the number or advertised characteristics of the representations available for a resource are considered sensitive, the <spanx style="verb">Variants</spanx> header by its nature will leak them.</t>

<t>Note that the <spanx style="verb">Variants</spanx> header is not a commitment to make representations of a certain nature available; the runtime behaviour of the server always overrides hints like <spanx style="verb">Variants</spanx>.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>This protocol is conceptually similar to, but simpler than, Transparent Content Negotiation <xref target="RFC2295"/>. Thanks to its authors for their inspiration.</t>

<t>It is also a generalisation of a Fastly VCL feature designed by Rogier ‘DocWilco’ Mulhuijzen.</t>

<t>Thanks to Hooman Beheshti for his review and input.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC7231" target='https://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference  anchor="RFC7234" target='https://www.rfc-editor.org/info/rfc7234'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.</t></abstract>
</front>
<seriesInfo name='RFC' value='7234'/>
<seriesInfo name='DOI' value='10.17487/RFC7234'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC4647" target='https://www.rfc-editor.org/info/rfc4647'>
<front>
<title>Matching of Language Tags</title>
<author initials='A.' surname='Phillips' fullname='A. Phillips'><organization /></author>
<author initials='M.' surname='Davis' fullname='M. Davis'><organization /></author>
<date year='2006' month='September' />
<abstract><t>This document describes a syntax, called a &quot;language-range&quot;, for specifying items in a user's list of language preferences.  It also describes different mechanisms for comparing and matching these to language tags.  Two kinds of matching mechanisms, filtering and lookup, are defined.  Filtering produces a (potentially empty) set of language tags, whereas lookup produces a single language tag. Possible applications include language negotiation or content selection.  This document, in combination with RFC 4646, replaces RFC 3066, which replaced RFC 1766.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='47'/>
<seriesInfo name='RFC' value='4647'/>
<seriesInfo name='DOI' value='10.17487/RFC4647'/>
</reference>




    </references>

    <references title='Informative References'>





<reference anchor="I-D.ietf-httpbis-client-hints">
<front>
<title>HTTP Client Hints</title>

<author initials='I' surname='Grigorik' fullname='Ilya Grigorik'>
    <organization />
</author>

<date month='January' day='26' year='2018' />

<abstract><t>An increasing diversity of Web-connected devices and software capabilities has created a need to deliver optimized content for each device.  This specification defines an extensible and configurable set of HTTP request header fields, colloquially known as Client Hints, to address this.  They are intended to be used as input to proactive content negotiation; just as the Accept header field allows user agents to indicate what formats they prefer, Client Hints allow user agents to indicate device and agent specific preferences.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-client-hints-05' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-client-hints-05.txt' />
</reference>



<reference  anchor="RFC2295" target='https://www.rfc-editor.org/info/rfc2295'>
<front>
<title>Transparent Content Negotiation in HTTP</title>
<author initials='K.' surname='Holtman' fullname='K. Holtman'><organization /></author>
<author initials='A.' surname='Mutz' fullname='A. Mutz'><organization /></author>
<date year='1998' month='March' />
<abstract><t>HTTP allows web site authors to put multiple versions of the same information under a single URL.  Transparent content negotiation is an extensible negotiation mechanism, layered on top of HTTP, for automatically selecting the best version when the URL is accessed.  This enables the smooth deployment of new web data formats and markup tags. This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind.  Discussion and suggestions for improvement are requested.</t></abstract>
</front>
<seriesInfo name='RFC' value='2295'/>
<seriesInfo name='DOI' value='10.17487/RFC2295'/>
</reference>



<reference  anchor="RFC3864" target='https://www.rfc-editor.org/info/rfc3864'>
<front>
<title>Registration Procedures for Message Header Fields</title>
<author initials='G.' surname='Klyne' fullname='G. Klyne'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<author initials='J.' surname='Mogul' fullname='J. Mogul'><organization /></author>
<date year='2004' month='September' />
<abstract><t>This specification defines registration procedures for the message header fields used by Internet mail, HTTP, Netnews and other applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='90'/>
<seriesInfo name='RFC' value='3864'/>
<seriesInfo name='DOI' value='10.17487/RFC3864'/>
</reference>




    </references>


<section anchor="backports" title="Variants for Existing Content Negotiation Mechanisms">

<t>This appendix defines the required information to use existing proactive content negotiation mechanisms (as defined in <xref target="RFC7231"/>, Section 5.3) with the <spanx style="verb">Variants</spanx> header field.</t>

<section anchor="content-type" title="Accept">

<t>This section defines handling for <spanx style="verb">Accept</spanx> variants, as per <xref target="RFC7231"/> Section 5.3.2.</t>

<t>To perform content negotiation for Accept given a request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-available be an empty list.</t>
  <t>Let preferred-types be a list of the types in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.2 (omitting any coding with a weight of 0). If “Accept” is not present or empty, preferred-types will be empty. If a type lacks an explicit weight, an implementation MAY assign one.</t>
  <t>If preferred-types is empty, append “<spanx style="emph">/</spanx>”.</t>
  <t>For each preferred-type in preferred-types:
  <list style="numbers">
      <t>If any member of available-values matches preferred-type, using the media-range matching mechanism specified in <xref target="RFC7231"/> Section 5.3.2 (which is case-insensitive), append those members of available-values to preferred-available (preserving the precedence order implied by the media ranges’ specificity).</t>
    </list></t>
  <t>Return preferred-available.</t>
</list></t>

<t>Note that this algorithm explicitly ignores extension parameters on media types (e.g., “charset”).</t>

</section>
<section anchor="content-encoding" title="Accept-Encoding">

<t>This section defines handling for <spanx style="verb">Accept-Encoding</spanx> variants, as per <xref target="RFC7231"/> Section 5.3.4.</t>

<t>To perform content negotiation for Accept-Encoding given a request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-available be an empty list.</t>
  <t>Let preferred-codings be a list of the codings in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.1 (omitting any coding with a weight of 0). If “Accept-Encoding” is not present or empty, preferred-codings will be empty. If a coding lacks an explicit weight, an implementation MAY assign one.</t>
  <t>If “identity” is not a member of preferred-codings, append “identity”.</t>
  <t>Append “identity” to available-values.</t>
  <t>For each preferred-coding in preferred-codings:
  <list style="numbers">
      <t>If there is a case-insensitive, character-for-character match for preferred-coding in available-values, append that member of available-values to preferred-available.</t>
    </list></t>
  <t>Return preferred-available.</t>
</list></t>

<t>Note that the unencoded variant needs to have a Variant-Key header field with a value of “identity”.</t>

</section>
<section anchor="content-language" title="Accept-Language">

<t>This section defines handling for <spanx style="verb">Accept-Language</spanx> variants, as per <xref target="RFC7231"/> Section 5.3.5.</t>

<t>To perform content negotiation for Accept-Language given a request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-available be an empty list.</t>
  <t>Let preferred-langs be a list of the language-ranges in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.1 (omitting any language-range with a weight of 0). If a language-range lacks a weight, an implementation MAY assign one.</t>
  <t>If the first member of available-values is not a member of preferred-langs, append it to preferred-langs (thus making it the default).</t>
  <t>For each preferred-lang in preferred-langs:
  <list style="numbers">
      <t>If any member of available-values matches preferred-lang, using either the Basic or Extended Filtering scheme defined in <xref target="RFC4647"/> Section 3.3, append those members of available-values to preferred-available (preserving their order).</t>
    </list></t>
  <t>Return preferred-available.</t>
</list></t>

</section>
</section>


  </back>

<!-- ##markdown-source:
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

-->

</rfc>

