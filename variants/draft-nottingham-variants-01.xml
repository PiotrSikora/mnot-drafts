<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.1.2 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-variants-01" category="std" updates="7234">

  <front>
    <title>HTTP Representation Variants</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date year="2017"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification introduces the HTTP “Variants” response header field to communicate what representations are available for a given resource, and the companion “Variant-Key” response header field to indicate which representation was selected. It is an augmentation of the “Vary” mechanism in HTTP caching.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/variants">https://github.com/mnot/I-D/labels/variants</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/variants/">https://mnot.github.io/I-D/variants/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/variants">https://github.com/mnot/I-D/commits/gh-pages/variants</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-variants/">https://datatracker.ietf.org/doc/draft-nottingham-variants/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP proactive content negotiation (<xref target="RFC7231"/>, Section 3.4.1) is starting to be used more widely again. The most widely seen use – determining a response’s content-coding – is being joined by renewed interest in negotiation for language and other, newer attributes (for example, see <xref target="I-D.ietf-httpbis-client-hints"/>).</t>

<t>Successfully reusing negotiated responses that have been stored in a HTTP cache requires establishment of a secondary cache key (<xref target="RFC7234"/>, Section 4.1) using the Vary header (<xref target="RFC7231"/>, Section 7.1.4), which identifies the request headers that form the secondary cache key for a given response.</t>

<t>HTTP’s caching model allows a certain amount of latitude in normalising request header fields identified by Vary to match those stored in the cache, so as to increase the chances of a cache hit while still respecting the semantics of that header. However, this is often inadequate; even with understanding of the headers’ semantics to facilitate such normalisation, a cache does not know enough about the possible alternative representations available on the origin server to make an appropriate decision.</t>

<t>For example, if a cache has stored the following request/response pair:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: text/html
Content-Language: fr
Vary: Accept-Language
Transfer-Encoding: chunked

[French content]
]]></artwork></figure>

<t>Provided that the cache has full knowledge of the semantics of Accept-Language and Content-Language, it will know that a French representation is available and might be able to infer that an English representation is not available. But, it does not know (for example) whether a Japanese representation is available without making another request, thereby incurring possibly unnecessary latency.</t>

<t>This specification introduces the HTTP Variants response header field (<xref target="variants"/>) to enumerate the available variant representations on the origin server, to provide clients and caches with enough information to properly satisfy requests – either by selecting a response from cache or by forwarding the request towards the origin – by following an algorithm defined in <xref target="cache"/>.</t>

<t>Its companion the Variant-Key response header field (<xref target="variant-key"/>) indicates which representation was selected, so that it can be reliably reused in the future.</t>

<t>This mechanism requires that proactive content negotiation mechanisms define how they use it; see <xref target="define"/>. It is best suited for negotiation over request attributes that are well-understood. It also works best when content negotiation takes place over a constrained set of representations; since each variant needs to be listed in the header field, it is ill-suited for open-ended sets of representations.</t>

<t>It is a simpler version of the Alternates header field introduced by <xref target="RFC2295"/>; unlike that mechanism, Variants does not require specification of each combination of attributes, and does not assume that each combination has a unique URL.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

<t>This specification uses the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/> with a list extension, defined in Section 7 of <xref target="RFC7230"/>, that allows for compact definition of comma-separated lists using a ‘#’ operator (similar to how the ‘*’ operator indicates repetition).</t>

<t>Additionally, it uses the “field-name”, “OWS” and “token” rules from <xref target="RFC7230"/>.</t>

</section>
</section>
<section anchor="variants" title="The “Variants” HTTP Header Field">

<t>The Variants HTTP response header field is used to indicate what other representations are available for a given resource at the time that the response is produced.</t>

<figure><artwork><![CDATA[
Variants        = 1#variant-item
variant-item    = field-name *( OWS ";" OWS available-value )
available-value = token
]]></artwork></figure>

<t>Each “variant-item” indicates a request header field that carries a value that clients might proactively negotiate for; each parameter on it indicates a value for which there is an available representation on the origin server.</t>

<t>So, given this example header field:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip
]]></artwork></figure>

<t>a recipient can infer that the only content-coding available for that resource is “gzip” (along with the “identity” non-encoding; see <xref target="content-encoding"/>).</t>

<t>Given:</t>

<figure><artwork><![CDATA[
Variants: accept-encoding
]]></artwork></figure>

<t>a recipient can infer that no content-codings (beyond identity) are supported. Note that as always with header field names, it is case-insensitive.</t>

<t>A more complex example:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip;br, Accept-Language;en ;fr
]]></artwork></figure>

<t>Here, recipients can infer that two content-codings in addition to “identity” are available, as well as two content languages. Note that, as with all HTTP header fields that use the “#” list rule (see <xref target="RFC7230"/>, Section 7), they might occur in the same header field or separately, like this:</t>

<figure><artwork><![CDATA[
Variants: Accept-Encoding;gzip;brotli
Variants: Accept-Language;en ;fr
]]></artwork></figure>

<t>The ordering of available-values after the field-name is significant, as it might be used by the header’s algorithm for selecting a response.</t>

<t>The ordering of the request header fields themselves indicates descending application of preferences; for example, in the headers above, a cache will serve gzip’d content regardless of language if it is available.</t>

<t>Origin servers SHOULD consistently send Variant header fields on all cacheable (as per <xref target="RFC7234"/>, Section 3) responses for a resource, since its absence will trigger caches to fall back to Vary processing.</t>

<t>Likewise, servers MUST send the Variant-Key response header field when sending Variants.</t>

<section anchor="vary" title="Relationship to Vary">

<t>Caches that fully implement this specification SHOULD ignore request header fields in the <spanx style="verb">Vary</spanx> header for the purposes of secondary cache key calculation (<xref target="RFC7234"/>, Section 4.1) when their semantics are understood, implemented as per this specification, and their corresponding response header field is listed in <spanx style="verb">Variants</spanx>.</t>

<t>If any member of the Vary header does not have a corresponding variant that is understood by the implementation, it is still subject to the requirements there.</t>

</section>
</section>
<section anchor="variant-key" title="The “Variant-Key” HTTP Header Field">

<t>The Variant-Key HTTP response header field is used to indicate the value(s) from the Variants header field that identify the representation it occurs within.</t>

<figure><artwork><![CDATA[
Variant-Key     = 1#available-value
]]></artwork></figure>

<t>Each value indicates the selected available-value, in the same order as the variants listed in the Variants header field.</t>

<t>For example:</t>

<figure><artwork><![CDATA[
Variants: Content-Encoding;gzip;br, Content-Language;en ;fr
Variant-Key: gzip, fr
]]></artwork></figure>

<t>This header pair indicates that the representation is used for responses that have a “gzip” content-coding and “fr” content-language.</t>

<t>Note that this is different than the semantics of any Content-* header that might be associated with the response; in the example above, it might be that a gzip’d version of the French content is not available, in which case it will not include “Content-Encoding: gzip”.</t>

</section>
<section anchor="define" title="Defining Content Negotiation Using Variants">

<t>To be usable with Variants, proactive content negotiation mechanisms need to be specified to take advantage of it. Specifically, they:</t>

<t><list style="symbols">
  <t>MUST define a request header field that advertises the clients preferences or capabilities, whose field-name SHOULD begin with “Accept-“.</t>
  <t>MUST define the syntax of available-values that will occur in Variants and Variant-Key.</t>
  <t>MUST define an algorithm for selecting a result. It MUST return a list of available-values that are suitable for the request, in order of preference, given the value of the request header nominated above and an available-values-list from the Variants header. If the result is an empty list, it implies that the cache cannot satisfy the request.</t>
</list></t>

<t><xref target="backports"/> fulfils these requirements for some existing proactive content negotiation mechanisms in HTTP.</t>

</section>
<section anchor="cache" title="Cache Behaviour">

<t>Caches that implement the Variants header field and the relevant semantics of the field-name it contains can use that knowledge to either select an appropriate stored representation, or forward the request if no appropriate representation is stored.</t>

<t>They do so by running this algorithm (or its functional equivalent) upon receiving a request, incoming-request:</t>

<t><list style="numbers">
  <t>Let selected-responses be a list of the stored responses suitable for reuse as defined in <xref target="RFC7234"/> Section 4, excepting the requirement to calculate a secondary cache key.</t>
  <t>Order selected-responses by the “Date” header field, most recent to least recent.</t>
  <t>If the freshest (as per <xref target="RFC7234"/>, Section 4.2) has one or more “Variants” header field(s):
  <list style="numbers">
      <t>Select one member of selected_responses and let its “Variants” header field-value(s) be variants-header. This SHOULD be the most recent response, but MAY be from an older one as long as it is still fresh.</t>
      <t>Let sorted-variants be an empty list.</t>
      <t>For each variant in variants-header:
      <list style="numbers">
          <t>If variant’s field-name corresponds to the response header field identified by a content negotiation mechanism that the implementation supports:
          <list style="numbers">
              <t>Let request-value be the field-value of the request header field(s) identified by the content negotiation mechanism.</t>
              <t>Let available-values be a list containing all available-value for the variant.</t>
              <t>Let sorted-values be the result of running the algorithm defined by the content negotiation mechanism with request-value and available-values.</t>
              <t>Append sorted-values to sorted-variants.</t>
            </list></t>
        </list>
At this point, sorted-variants will be a list of lists, each member of the top-level list corresponding to a variant-item in the Variants header field-value, containing zero or more items indicating available-values that are acceptable to the client, in order of preference, greatest to least.</t>
      <t>If any member of sorted-variants is an empty list, stop processing and forward the request towards the origin, since an acceptable response is not stored in the cache.</t>
      <t>Let sorted-keys be the result of running Find Available Keys (<xref target="find"/>) on sorted-variants and two empty lists.</t>
    </list></t>
</list></t>

<t>This will result in a list of lists, where each member of the top-level list indicates, in preference order, a key for an acceptable response to the request.</t>

<t>A Cache MAY satisfy the request with any response whose Variant-Key header corresponds to a member of sorted-keys; when doing so, it SHOULD use the most preferred available response.</t>

<t>See also <xref target="vary"/> regarding handling of Vary.</t>

<section anchor="example-of-cache-behaviour" title="Example of Cache Behaviour">

<t>For example, if the selected variants-header was:</t>

<figure><artwork><![CDATA[
Variants: Accept-Language;en;fr,de, Accept-Encoding;gzip,br
]]></artwork></figure>

<t>and the request contained the headers:</t>

<figure><artwork><![CDATA[
Accept-Language: fr;q=1.0, en;q=0.1
Accept-Encoding: gzip
]]></artwork></figure>

<t>Then the sorted-variants would be:</t>

<figure><artwork><![CDATA[
[
  ["fr", "en"]           // prefers French, will accept English
  ["gzip", "identity"]   // prefers gzip encoding, will accept identity
]
]]></artwork></figure>

<t>Which means that the sorted-keys would be:</t>

<figure><artwork><![CDATA[
[
  ['fr', 'gzip'], 
  ['fr', 'identity'], 
  ['en', 'gzip'], 
  ['en', 'identity']
]
]]></artwork></figure>

<t>Representing a first preference of a French, gzip’d response. Thus, if a cache has a response with:</t>

<figure><artwork><![CDATA[
Variant-Key: fr, gzip
]]></artwork></figure>

<t>it could be used to satisfy the first preference.</t>

</section>
<section anchor="find" title="Find Available Keys">

<t>Given sorted-variants, a list of lists, and key-stub, a list representing a partial key, and possible-keys, a list:</t>

<t><list style="numbers">
  <t>Let sorted-values be the first member of sorted-variants.</t>
  <t>For each sorted-value in sorted-values:
  <list style="numbers">
      <t>Let this-key be a copy of key-stub.</t>
      <t>Append sorted-value to this-key.</t>
      <t>Let remaining-variants be a copy of all of the members of sorted-variants except the first.</t>
      <t>If remaining-variants is empty, append this-key to possible-keys.</t>
      <t>Else, run Find Available Keys on remaining-variants, this-key and possible-keys.</t>
      <t>Return possible-keys.</t>
    </list></t>
</list></t>

</section>
</section>
<section anchor="examples" title="Example Headers">

<section anchor="single-variant" title="Single Variant">

<t>Given a request/response pair:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Cache-Control: max-age=3600
Variants: Content-Language;en;de
Variant-Key: en
Vary: Accept-Language
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Upon receipt of this response, the cache knows that two representations of this resource are available, one with a <spanx style="verb">Content-Language</spanx> of “en”, and another whose <spanx style="verb">Content-Language</spanx> is “de”.</t>

<t>Subsequent requests (while this response is fresh) will cause the cache to either reuse this response or forward the request, depending on what the selection algorithm determines.</t>

<t>So, if a request with “en” in <spanx style="verb">Accept-Language</spanx> is received and its q-value indicates that it is acceptable, the stored response is used. A request that indicates that “de” is acceptable will be forwarded to the origin, thereby populating the cache. A cache receiving a request that indicates both languages are acceptable will use the q-value to make a determination of what response to return.</t>

<t>A cache receiving a request that does not list either language as acceptable (or does not contain an Accept-Language at all) will return the “en” representation (possibly fetching it from the origin), since it is listed first in the <spanx style="verb">Variants</spanx> list.</t>

<t>Note that <spanx style="verb">Accept-Language</spanx> is listed in Vary, to assure backwards-compatibility with caches that do not support <spanx style="verb">Variants</spanx>.</t>

</section>
<section anchor="multiple-variants" title="Multiple Variants">

<t>A more complicated request/response pair:</t>

<figure><artwork><![CDATA[
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Language;en;jp;de
Variants: Content-Encoding;br;gzip
Variant-Key: en, br
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache knows that there are two axes that the response varies upon; <spanx style="verb">Content-Language</spanx> and <spanx style="verb">Content-Encoding</spanx>. Thus, there are a total of six possible representations for the resource, and the cache needs to consider the selection algorithms for both axes.</t>

<t>Upon a subsequent request, if both selection algorithms return a stored representation, it can be served from cache; otherwise, the request will need to be forwarded to origin.</t>

</section>
<section anchor="partial-coverage" title="Partial Coverage">

<t>Now, consider the previous example, but where only one of the Vary’d axes is listed in <spanx style="verb">Variants</spanx>:</t>

<figure><artwork><![CDATA[
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Encoding;br;gzip
Variant-Key: br
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache will need to calculate a secondary cache key as per <xref target="RFC7234"/>, Section 4.1 – but considering only <spanx style="verb">Accept-Language</spanx> to be in its field-value – and then continue processing <spanx style="verb">Variants</spanx> for the set of stored responses that the algorithm described there selects.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This specification registers two values in the Permanent Message Header Field Names registry established by <xref target="RFC3864"/>:</t>

<t><list style="symbols">
  <t>Header field name: Variants</t>
  <t>Applicable protocol: http</t>
  <t>Status: standard</t>
  <t>Author/Change Controller: IETF</t>
  <t>Specification document(s): [this document]</t>
  <t>Related information:</t>
  <t>Header field name: Variant-Key</t>
  <t>Applicable protocol: http</t>
  <t>Status: standard</t>
  <t>Author/Change Controller: IETF</t>
  <t>Specification document(s): [this document]</t>
  <t>Related information:</t>
</list></t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>If the number or advertised characteristics of the representations available for a resource are considered sensitive, the <spanx style="verb">Variants</spanx> header by its nature will leak them.</t>

<t>Note that the <spanx style="verb">Variants</spanx> header is not a commitment to make representations of a certain nature available; the runtime behaviour of the server always overrides hints like <spanx style="verb">Variants</spanx>.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>This protocol is conceptually similar to, but simpler than, Transparent Content Negotiation <xref target="RFC2295"/>. Thanks to its authors for their inspiration.</t>

<t>It is also a generalisation of a Fastly VCL feature designed by Rogier ‘DocWilco’ Mulhuijzen.</t>

<t>Thanks to Hooman Beheshti for his review and input.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC7231" target='https://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference  anchor="RFC7234" target='https://www.rfc-editor.org/info/rfc7234'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.</t></abstract>
</front>
<seriesInfo name='RFC' value='7234'/>
<seriesInfo name='DOI' value='10.17487/RFC7234'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC4647" target='https://www.rfc-editor.org/info/rfc4647'>
<front>
<title>Matching of Language Tags</title>
<author initials='A.' surname='Phillips' fullname='A. Phillips'><organization /></author>
<author initials='M.' surname='Davis' fullname='M. Davis'><organization /></author>
<date year='2006' month='September' />
<abstract><t>This document describes a syntax, called a &quot;language-range&quot;, for specifying items in a user's list of language preferences.  It also describes different mechanisms for comparing and matching these to language tags.  Two kinds of matching mechanisms, filtering and lookup, are defined.  Filtering produces a (potentially empty) set of language tags, whereas lookup produces a single language tag. Possible applications include language negotiation or content selection.  This document, in combination with RFC 4646, replaces RFC 3066, which replaced RFC 1766.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='47'/>
<seriesInfo name='RFC' value='4647'/>
<seriesInfo name='DOI' value='10.17487/RFC4647'/>
</reference>




    </references>

    <references title='Informative References'>





<reference anchor="I-D.ietf-httpbis-client-hints">
<front>
<title>HTTP Client Hints</title>

<author initials='I' surname='Grigorik' fullname='Ilya Grigorik'>
    <organization />
</author>

<date month='April' day='18' year='2017' />

<abstract><t>An increasing diversity of Web-connected devices and software capabilities has created a need to deliver optimized content for each device.  This specification defines a set of HTTP request header fields, colloquially known as Client Hints, to address this.  They are intended to be used as input to proactive content negotiation; just as the Accept header field allows user agents to indicate what formats they prefer, Client Hints allow user agents to indicate device and agent specific preferences.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-client-hints-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-client-hints-04.txt' />
</reference>



<reference  anchor="RFC2295" target='https://www.rfc-editor.org/info/rfc2295'>
<front>
<title>Transparent Content Negotiation in HTTP</title>
<author initials='K.' surname='Holtman' fullname='K. Holtman'><organization /></author>
<author initials='A.' surname='Mutz' fullname='A. Mutz'><organization /></author>
<date year='1998' month='March' />
<abstract><t>HTTP allows web site authors to put multiple versions of the same information under a single URL.  Transparent content negotiation is an extensible negotiation mechanism, layered on top of HTTP, for automatically selecting the best version when the URL is accessed.  This enables the smooth deployment of new web data formats and markup tags. This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind.  Discussion and suggestions for improvement are requested.</t></abstract>
</front>
<seriesInfo name='RFC' value='2295'/>
<seriesInfo name='DOI' value='10.17487/RFC2295'/>
</reference>



<reference  anchor="RFC3864" target='https://www.rfc-editor.org/info/rfc3864'>
<front>
<title>Registration Procedures for Message Header Fields</title>
<author initials='G.' surname='Klyne' fullname='G. Klyne'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<author initials='J.' surname='Mogul' fullname='J. Mogul'><organization /></author>
<date year='2004' month='September' />
<abstract><t>This specification defines registration procedures for the message header fields used by Internet mail, HTTP, Netnews and other applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='90'/>
<seriesInfo name='RFC' value='3864'/>
<seriesInfo name='DOI' value='10.17487/RFC3864'/>
</reference>




    </references>


<section anchor="backports" title="Variants and Defined Content Negotiation Mechanisms">

<t>This appendix defines the required information to use existing proactive content negotiation mechanisms (as defined in <xref target="RFC7231"/>, Section 5.3) with the <spanx style="verb">Variants</spanx> header field.</t>

<section anchor="content-encoding" title="Content-Encoding">

<t>When negotiating for the <spanx style="verb">Content-Encoding</spanx> response header field’s value, the applicable request header field is <spanx style="verb">Accept-Encoding</spanx>, as per <xref target="RFC7231"/> Section 5.3.4.</t>

<t>To perform content negotiation for Content-Encoding given an request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-codings be a list of the codings in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.1 (omitting any coding with a weight of 0). If “Accept-Encoding” is not present or empty, preferred-codings will be empty.</t>
  <t>If “identity” is not a member of preferred-codings, append “identity”.</t>
  <t>Append “identity” to available-values.</t>
  <t>Remove any member of available-values not present in preferred-codings, comparing in a case-insensitive fashion.</t>
  <t>Return available-values.</t>
</list></t>

<t>Implementations MAY remove other members of <spanx style="verb">available-responses</spanx> based upon their <spanx style="verb">weight</spanx> or other criteria before returning. For example, they might wish to return an empty list when the client’s most-preferred available response is not stored, so as to populate the cache as well as honour the client’s preferences.</t>

</section>
<section anchor="content-language" title="Content-Language">

<t>When negotiating for the <spanx style="verb">Content-Language</spanx> response header field’s value, the applicable request header field is <spanx style="verb">Accept-Language</spanx>, as per <xref target="RFC7231"/> Section 5.3.5.</t>

<t>To perform content negotiation for Content-Language given an request-value and available-values:</t>

<t><list style="numbers">
  <t>Let preferred-langs be a list of the language-ranges in the request-value, ordered by their weight, highest to lowest, as per <xref target="RFC7231"/> Section 5.3.1 (omitting any language-range with a weight of 0).</t>
  <t>If preferred-langs is empty, append “*”.</t>
  <t>Filter available-values using preferred-langs with either the Basic Filtering scheme defined in <xref target="RFC4647"/> Section 3.3.1, or the Lookup scheme defined in Section 3.4 of that document. Use the first member of available-values as the default.</t>
  <t>Return available-values.</t>
</list></t>

<t>Implementations MAY remove members of available-values based upon their weight or other criteria before returning. For example, they might wish to return an empty list when the client’s most-preferred available response is not stored, so as to populate the cache as well as honour the client’s preferences.</t>

</section>
</section>


  </back>

<!-- ##markdown-source:
H4sIALrN8lkAA+VcWXPbxpZ+x6/ooR8kuUhKsuXkhprMjGzLsSfeRpZv6pbL
FTWBJtkRCCBoQDSjUn77nKW70Vgk2XNnq5k8OBIJ9HKW73zn9GlNJpOo0lWq
ZuLl+fl7caaKUhmVVbLSeSb+Kksts8pEcj4v1dUsSvI4k2t4OinloppkeVXp
bLmS68mVfXRycBglsoJHHh0cfh/F8OMyL7czYaokqgv8yszE948eH0WRLsqZ
qMraVI8ODn44eBTJUsmZ+EllqpRptMnLy2WZ18UsulRb+C2ZiVdZpcpMVZPn
uIAoMpXMkl9lmmcw41aZqNAz8anK47GAf3SWwF7GwuRlVaqFgZ+2a/tDVeoY
vorzdSHtD2t4GL7SWaoz9TmKZF2t8nIWiUkk4D+dwcrfTMVbv2v6mAXyRpaX
3W/ycikz/QfJciZeSFOlW/pCraVOZ2IN8vsX/GcKO6Iv6hKWv6qqwsz29zeb
zdR9ux9FWV6uYagrBQsSZy+ePTo8/GEGQswWzRdRNJlMhJzD7mBTUXS+0kaY
QsV6oWPWqc6qMk/qWBlRrRSrfeQUPRKg/iLPjBIrJRNVioVWaQKyJPnUGY6i
xGYlK3gytBUjQHlCXsHG5DxVAhYlpFjCqjIcM6/LWI0FKItmJalnuBw39eRn
tb1jdtCkm1rHq87cYiNhlypVcaWSqXhVCdi1zISsl2v/TL6gmXE+mGit4hUs
wKxhZJZBLOMV6G7KIgSxq1/f4j9V/usZLcZE0UMQuzh9/ur83dlMFKmSsNJS
rfMrBWOjpGEFONdcwfaVKOp5asX+EHWhYF2mBsGn2lQkIXqLfAnmx/fg0xpk
BOL9R2cGS12t6vkURLaP1rD/avJ8H2SsUrPvnO6fpjz8Ojeolxg2LXbzRaWy
sagzWoZZqWTPToXSCSYgG7Oz6JzGdwPv48hnPCAKbKlYz7gBdf8y0WY0jLJc
TQoJ77YW/EGBvaQmJ7XQwnaMiOuyxMnAr6vaoHLw21en5y8EQIdEs75UJRhS
FfmZgy+mWlWLKfjdPiDV/q0gRdtCNa91kqQqih4gsJBboLKiiCyiKHNwIrBg
MFeAHVhVBlhWaban3evrfwBzACQ7vLkZiw9W9Y+nR9PDPRQxbKHEidF8QbG1
AYGt0Sw2OlHpVsil1NlUeL3Zj40Cj4GHBSwvUYB2a53hKNI7B4qJFzSJ8wS/
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

-->

</rfc>

